{"version":3,"file":"tools/isobuild/resolver.js.map","mappings":"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","names":["module1","default","_defineProperty","Resolver","isString","isObject","has","matches","archMatches","isLegacyArch","pathJoin","pathNormalize","pathDirname","pathBasename","convertToOSPath","convertToPosixPath","containsPath","wrap","optimisticStatOrNull","optimisticReadJsonOrNull","Profile","nativeModulesMap","Object","create","nativeNames","require","builtinModules","forEach","id","constructor","sourceRoot","targetArch","extensions","nodeModulesPaths","statOrNull","resolve","absParentPath","call","makeCacheKey","JSON","stringify","findPkgJsonSubsetForPath","getPkgJsonSubsetForDir","path","mainFields","isTopLevel","indexOf","charAt","isNative","getNativeStubId","_seenDirPaths","resolved","resolveAbsolute","resolveRelative","resolveNodeModule","packageJsonMap","stat","isDirectory","dirPath","Set","add","found","foundPkgJsonMain","some","name","value","pkg","joinAndStat","assign","pkgJsonInfo","browser","joined","exactStat","exactResult","result","isFile","parentDirStat","ext","pathWithExt","_absParentPath","slice","dir","dirStat","parentDir","pkgJsonPath","pkgSubset","version","options","Rp","prototype","keys","key"],"sourceRoot":"","sources":["tools/isobuild/resolver.ts"],"sourcesContent":["import {\n  isString,\n  isObject,\n  has,\n} from \"underscore\";\n\nimport { matches as archMatches, isLegacyArch } from \"../utils/archinfo\";\nimport {\n  pathJoin,\n  pathNormalize,\n  pathDirname,\n  pathBasename,\n  convertToOSPath,\n  convertToPosixPath,\n  containsPath,\n} from \"../fs/files\";\nimport { Stats, BigIntStats } from \"fs\";\nimport { wrap } from \"optimism\";\nimport {\n  optimisticStatOrNull,\n  optimisticReadJsonOrNull,\n} from \"../fs/optimistic\";\n\nconst nativeModulesMap: Record<string, string> = Object.create(null);\nconst nativeNames = require('module').builtinModules;\n\nnativeNames.forEach((id: string) => {\n  // When a native Node module is imported, we register a dependency on a\n  // meteor-node-stubs/deps/* module of the same name, so that the\n  // necessary stub modules will be included in the bundle. This alternate\n  // identifier will not be imported at runtime, but the modules it\n  // depends on are necessary for the original import to succeed.\n  nativeModulesMap[id] =  \"meteor-node-stubs/deps/\" + id;\n});\n\nexport type ResolverOptions = {\n  sourceRoot: string;\n  targetArch: string;\n  extensions: string[];\n  nodeModulesPaths: string[];\n  caller?: string;\n}\n\nexport type Resolution = {\n  stat: Stats | BigIntStats;\n  path: string;\n  packageJsonMap?: Record<string, Record<string, any>>;\n  id?: string;\n} | \"missing\" | null\n\nexport default class Resolver {\n  static getOrCreate = wrap(function (options: ResolverOptions) {\n    return new Resolver(options);\n  }, {\n    makeCacheKey(options) {\n      return JSON.stringify(options);\n    }\n  });\n\n  private sourceRoot: string;\n  private targetArch: string;\n  private extensions: string[];\n  private nodeModulesPaths: string[];\n  private mainFields: string[];\n\n  public statOrNull = optimisticStatOrNull as (path: string) => Stats | BigIntStats | null | undefined;\n\n  constructor({\n    sourceRoot,\n    targetArch,\n    extensions = [\".js\", \".json\"],\n    nodeModulesPaths = [],\n  }: ResolverOptions) {\n    this.sourceRoot = sourceRoot;\n    this.extensions = extensions;\n    this.targetArch = targetArch;\n    this.nodeModulesPaths = nodeModulesPaths;\n    this.statOrNull = optimisticStatOrNull;\n\n    const { resolve } = this;\n    this.resolve = wrap((id, absParentPath) => {\n      return resolve.call(this, id, absParentPath);\n    }, {\n      makeCacheKey(id, absParentPath) {\n        // Only the directory of the absParentPath matters for caching.\n        return JSON.stringify([id, pathDirname(absParentPath)]);\n      }\n    });\n\n    const {\n      findPkgJsonSubsetForPath,\n      getPkgJsonSubsetForDir,\n    } = this;\n\n    this.findPkgJsonSubsetForPath = wrap(\n      path => findPkgJsonSubsetForPath.call(this, path));\n\n    this.getPkgJsonSubsetForDir = wrap(\n      path => getPkgJsonSubsetForDir.call(this, path));\n\n    if (archMatches(this.targetArch, \"web\")) {\n      if (isLegacyArch(this.targetArch)) {\n        // The legacy bundle prefers the \"main\" field over the \"module\"\n        // field, since many npm packages ship modern syntax other than\n        // import/export in their \"module\" dependency trees.\n        this.mainFields = [\"browser\", \"main\", \"module\"];\n      } else {\n        this.mainFields = [\"browser\", \"module\", \"main\"];\n      }\n    } else {\n      this.mainFields = [\"main\"];\n    }\n  }\n\n  static isTopLevel(id: string) {\n    return \"./\".indexOf(id.charAt(0)) < 0;\n  }\n\n  static isNative(id: string): boolean {\n    return has(nativeModulesMap, id);\n  }\n\n  static getNativeStubId(id: string) {\n    return nativeModulesMap[id] || null;\n  }\n\n  // Resolve the given module identifier to an object { path, stat } or\n  // null, relative to an absolute parent path. The _seenDirPaths\n  // parameter is for internal use only and should be ommitted.\n  public resolve(\n    id: string,\n    absParentPath: string,\n    _seenDirPaths?: Set<string>,\n  ): Resolution {\n    let resolved =\n      this.resolveAbsolute(id, absParentPath) ||\n      this.resolveRelative(id, absParentPath) ||\n      this.resolveNodeModule(id, absParentPath);\n\n    if (resolved === \"missing\") {\n      // The _resolveNodeModule method can return \"missing\" to indicate\n      // that the ImportScanner should look elsewhere for this module,\n      // such as in the app node_modules directory.\n      return resolved;\n    }\n\n    let packageJsonMap = null;\n\n    while (resolved && resolved.stat && resolved.stat.isDirectory()) {\n      let dirPath = resolved.path;\n      _seenDirPaths = _seenDirPaths || new Set;\n\n      // If the \"main\" field of a package.json file resolves to a\n      // directory we've already considered, then we should not attempt to\n      // read the same package.json file again.\n      if (! _seenDirPaths.has(dirPath)) {\n        _seenDirPaths.add(dirPath);\n\n        const found = this.getPkgJsonSubsetForDir(dirPath);\n        const foundPkgJsonMain = found && this.mainFields.some(name => {\n          const value = found.pkg[name];\n          if (isString(value)) {\n            // The \"main\" field of package.json does not have to begin with ./\n            // to be considered relative, so first we try simply appending it\n            // to the directory path before falling back to a full resolve,\n            // which might return a package from a node_modules directory.\n            resolved = this.joinAndStat(dirPath, value) ||\n              this.resolve(value, found.path, _seenDirPaths);\n            return resolved && typeof resolved === \"object\";\n          }\n          return false;\n        });\n\n        if (foundPkgJsonMain && found) {\n          if (! resolved.packageJsonMap) {\n            resolved.packageJsonMap = Object.create(null);\n          }\n\n          resolved.packageJsonMap![found.path] = found.pkg;\n\n          // The resolution above may have returned a directory, so we\n          // merge resolved.packageJsonMap into packageJsonMap so that we\n          // don't forget the package.json we just resolved, then continue\n          // the loop to make sure we fully resolve the \"main\" module\n          // identifier to a non-directory.  Technically this could\n          // involve even more package.json files, but in practice the\n          // \"main\" property will almost always name a directory\n          // containing an index.js file.\n          Object.assign(\n            packageJsonMap || (packageJsonMap = Object.create(null)),\n            resolved.packageJsonMap,\n          );\n\n          continue;\n        }\n\n        // Include the package.json stub in the bundle even if it was not\n        // used to resolve the \"main\" entry point, per this comment:\n        // https://github.com/meteor/meteor/issues/9235#issuecomment-340562285\n        if (found) {\n          packageJsonMap = packageJsonMap || Object.create(null);\n          packageJsonMap[found.path] = found.pkg;\n        }\n      }\n\n      // If we didn't find a `package.json` file, or it didn't have a\n      // resolvable `.main` property, the only possibility left to\n      // consider is that this directory contains an `index.js` module.\n      // This assignment almost always terminates the while loop, because\n      // there's very little chance an `index.js` file will be a\n      // directory. However, in principle it is remotely possible that a\n      // file called `index.js` could be a directory instead of a file.\n      resolved = this.joinAndStat(dirPath, \"index\");\n    }\n\n    if (resolved) {\n      if (packageJsonMap) {\n        resolved.packageJsonMap = packageJsonMap;\n      }\n\n      // If the package.json file that governs resolved.path has a\n      // \"browser\" field, include it in resolved.packageJsonMap so that\n      // the ImportScanner can register the appropriate browser aliases.\n      const pkgJsonInfo = this.findPkgJsonSubsetForPath(resolved.path);\n      if (pkgJsonInfo &&\n          isObject(pkgJsonInfo.pkg.browser)) {\n        if (! resolved.packageJsonMap) {\n          resolved.packageJsonMap = Object.create(null);\n        }\n        resolved.packageJsonMap![pkgJsonInfo.path] = pkgJsonInfo.pkg;\n      }\n\n      resolved.id = convertToPosixPath(\n        convertToOSPath(resolved.path),\n        true\n      );\n    }\n\n    return resolved;\n  }\n\n  public joinAndStat(...joinArgs: string[]) {\n    const joined: string = pathJoin(...joinArgs);\n    const path = pathNormalize(joined);\n    const exactStat = this.statOrNull(path);\n    const exactResult = exactStat && { path, stat: exactStat };\n\n    let result: Resolution = null;\n\n    if (exactResult && exactStat && exactStat.isFile()) {\n      result = exactResult;\n    } else {\n      // No point in trying alternate file extensions if the parent\n      // directory does not exist.\n      const parentDirStat = this.statOrNull(pathDirname(path));\n      if (parentDirStat &&\n          parentDirStat.isDirectory()) {\n        this.extensions.some(ext => {\n          const pathWithExt = path + ext;\n          const stat = this.statOrNull(pathWithExt);\n          if (stat && ! stat.isDirectory()) {\n            return result = { path: pathWithExt, stat };\n          }\n        });\n      }\n    }\n\n    if (! result && exactResult && exactStat && exactStat.isDirectory()) {\n      // After trying all available file extensions, fall back to the\n      // original result if it was a directory.\n      result = exactResult;\n    }\n\n    return result;\n  }\n\n  private resolveAbsolute(id: string, _absParentPath: string): Resolution {\n    return id.charAt(0) === \"/\"\n      && this.joinAndStat(this.sourceRoot, id.slice(1))\n      || null;\n  }\n\n  private resolveRelative(id: string, absParentPath: string): Resolution {\n    if (id.charAt(0) === \".\") {\n      return this.joinAndStat(absParentPath, \"..\", id);\n    }\n    return null;\n  }\n\n  private resolveNodeModule(id: string, absParentPath: string): Resolution {\n    if (! Resolver.isTopLevel(id)) {\n      return null;\n    }\n\n    if (Resolver.isNative(id) &&\n        archMatches(this.targetArch, \"os\")) {\n      // Forbid installing any server module with the same name as a\n      // native Node module.\n      return null;\n    }\n\n    let sourceRoot: string | undefined;\n    if (containsPath(this.sourceRoot, absParentPath)) {\n      // If the file is contained by this.sourceRoot, then it's safe to\n      // use this.sourceRoot as the limiting ancestor directory in the\n      // while loop below, but we're still going to check whether the file\n      // resides in an external node_modules directory, since \"external\"\n      // .npm/package/node_modules directories are technically contained\n      // within the root directory of their packages.\n      sourceRoot = this.sourceRoot;\n    }\n\n    this.nodeModulesPaths.some(path => {\n      if (containsPath(path, absParentPath)) {\n        // If the file is inside an external node_modules directory,\n        // consider the rootDir to be the parent directory of that\n        // node_modules directory, rather than this.sourceRoot.\n        return sourceRoot = pathDirname(path);\n      }\n    });\n\n    let resolved = null;\n\n    if (sourceRoot) {\n      let dir = absParentPath; // It's ok for absParentPath to be a directory!\n      let dirStat = this.statOrNull(dir);\n      if (! (dirStat && dirStat.isDirectory())) {\n        dir = pathDirname(dir);\n      }\n\n      while (! (resolved = this.joinAndStat(dir, \"node_modules\", id))) {\n        if (dir === sourceRoot) {\n          break;\n        }\n\n        const parentDir = pathDirname(dir);\n        if (dir === parentDir) {\n          // We've reached the root of the file system??\n          break;\n        }\n\n        dir = parentDir;\n      }\n    }\n\n    if (! resolved) {\n      // After checking any local node_modules directories, fall back to\n      // the package NPM directory, if one was specified.\n      this.nodeModulesPaths.some(path => {\n        return resolved = this.joinAndStat(path, id);\n      });\n    }\n\n    // If the dependency is still not resolved, it might be handled by the\n    // fallback function defined in meteor/packages/modules-runtime/[modern|legacy|server].js, or\n    // it might be imported in code that will never run on this platform,\n    // so there is always the possibility that its absence is not actually\n    // a problem. As much as we might like to issue warnings about missing\n    // dependencies here, we just don't have enough information to make\n    // that determination until the code actually runs.\n\n    return resolved || \"missing\";\n  }\n\n  private getPkgJsonSubsetForDir(dirPath: string) {\n    const pkgJsonPath = pathJoin(dirPath, \"package.json\");\n    const pkg = optimisticReadJsonOrNull(pkgJsonPath);\n    if (! pkg) {\n      return null;\n    }\n\n    // Output a JS module that exports just the \"name\", \"version\", \"main\",\n    // and \"browser\" properties (if defined) from the package.json file.\n    const pkgSubset: Partial<typeof pkg> = {};\n\n    if (has(pkg, \"name\")) {\n      pkgSubset.name = pkg.name;\n    }\n\n    if (has(pkg, \"version\")) {\n      pkgSubset.version = pkg.version;\n    }\n\n    this.mainFields.forEach(name => {\n      const value = pkg[name];\n      if (isString(value) ||\n          isObject(value)) {\n        pkgSubset[name] = value;\n      }\n    });\n\n    return {\n      path: pkgJsonPath,\n      pkg: pkgSubset,\n    };\n  }\n\n  private findPkgJsonSubsetForPath(\n    path: string,\n  ): ReturnType<Resolver[\"getPkgJsonSubsetForDir\"]> {\n    const stat = this.statOrNull(path);\n\n    if (stat && stat.isDirectory()) {\n      const found = this.getPkgJsonSubsetForDir(path);\n      if (found) {\n        return found;\n      }\n\n      if (path === this.sourceRoot) {\n        return null;\n      }\n    }\n\n    const parentDir = pathDirname(path);\n\n    if (parentDir === path) {\n      return null;\n    }\n\n    if (pathBasename(parentDir) === \"node_modules\") {\n      return null;\n    }\n\n    return this.findPkgJsonSubsetForPath(parentDir);\n  }\n};\n\nimport { Profile } from \"../tool-env/profile\";\nconst Rp = Resolver.prototype as any;\nObject.keys(Rp).forEach(key => {\n  if (key === \"constructor\") return;\n  Rp[key] = Profile(`Resolver#${key}`, Rp[key]);\n});\n"]}