{"version":3,"file":"tools/fs/files.js.map","mappings":"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","names":["_defineProperty","module","default","_objectSpread","cwd","findAppDir","findPackageDir","findGitCommitHash","addToGitignore","inCheckout","usesWarehouse","getToolsVersion","getDevBundle","getCurrentNodeBinDir","getCurrentToolsDir","getSettings","containsPath","prettyPath","statOrNull","realpathOrNull","rm_recursive_async","rm_recursive","fileHash","blankHash","treeHash","mkdir_p","cp_r","symlinkWithOverwrite","getPathsInDir","findPathsWithRegex","mkdtemp","freeTempDir","changeTempDirStatus","extractTarGz","createTarGzStream","createTarball","renameDirAlmostAtomically","writeFileAtomically","symlinkOverSync","runJavaScript","FancySyntaxError","OfflineError","readdirNoDots","getLines","splitBufferToLines","getLinesOrEmpty","readJSONOrNull","trimSpaceAndComments","trimSpace","KeyValueFile","getHomeDir","currentEnvWithPathsAdded","_generateScriptLinkToMeteorScript","_getLocationFromScriptLinkToMeteorScript","linkToMeteorScript","readLinkToMeteorScript","exists","readBufferWithLengthAndOffset","withCache","dependOnPath","readFile","copyFile","rename","realpath","readdir","readdirWithTypes","appendFile","chmod","close","createReadStream","createWriteStream","lstat","mkdir","open","read","readlink","rmdir","stat","symlink","unlink","write","writeFile","watchFile","unwatchFile","fs","os","execFile","Slot","dep","convertToOSPath","convertToPosixPath","convertToStandardLineEndings","convertToStandardPath","convertToWindowsPath","isWindowsLikeFilesystem","pathBasename","pathDirname","pathJoin","pathNormalize","pathOsDelimiter","pathRelative","pathResolve","pathSep","_","require","Fiber","rimraf","sourcemap","sourceMapRetrieverStack","utils","cleanup","buildmessage","fiberHelpers","colonConverter","Profile","hasOwnProperty","Object","prototype","parsedSourceMaps","nextStackFilenameCounter","useParsedSourceMap","pathForSourceMap","call","map","push","canYield","current","yield","disallowed","findUpwards","predicate","startPath","testDir","newDir","process","filepath","isAppDir","isFile","e","isPackageDir","path","Promise","resolve","appDir","error","stdout","trim","await","dirPath","entry","filePath","data","lines","split","some","line","substr","once","console","log","env","METEOR_WAREHOUSE_DIR","isopackJsonPath","parsed","JSON","parse","name","version","unipackageJsonPath","Error","__dirname","filename","watchSet","assertInCapture","absPath","buffer","readAndWatchFile","file","length","str","toString","charCodeAt","slice","match","path1","path2","relPath","startsWith","p","home","relativeToHome","statOrNullHelper","preserveSymlinks","code","reject","err","sync","crypto","hash","createHash","setEncoding","rs","on","digest","pipe","end","root","optionsParams","options","ignore","traverse","relativePath","isDirectory","update","stringify","forEach","size","mode","isSymbolicLink","dir","ps","parentPath","join","success","pathIsDirectory","from","to","f","pattern","fullFrom","transformFilename","transformContents","source","target","args","platform","absoluteSource","normalizePath","replace","noYieldsAllowed","absoluteDir","output","newPath","newAbsPath","regex","filter","tempDirs","create","prefix","make","tmpDir","t","value","tries","Math","random","METEOR_SAVE_TMPDIRS","then","status","onExit","entries","isTmp","destPath","parentDir","tempDir","randomToken","verbose","Console","startTime","Date","promise","tryExtractWithNpmTar","topLevelOfArchive","extractDir","now","ensureDirectoryEmpty","tar","zlib","gunzip","createGunzip","extractor","extract","readable","writable","header","forceConvert","convert","addExecBitWhenReadBitPresent","fileMode","basename","binPathMatch","tarStream","pack","type","includes","createGzip","tarball","out","fromDir","toDir","garbageDir","cleanupGarbage","forceCopy","contents","tmpFile","linkText","tmpSymlink","symbols","sourceMap","sourceMapRoot","time","keys","values","each","stackFilename","chunks","sourcemapConsumer","SourceMapConsumer","SourceNode","fromStringWithSourceMap","destroy","wrapped","parsedSourceMap","results","toStringWithSourceMap","toJSON","sourceRoot","sourcesContent","script","createScript","nodeParseError","SyntaxError","strictMode","parseError","loc","message","consumer2","original","originalPositionFor","column","markBoundary","runInThisContext","apply","constructor","exports","pop","raw","set","k","v","readAll","found","i","trimmed","indexOf","newdata","MI","METEOR_INSTALLATION","HOME","pathPropertyName","find","key","toUpperCase","paths","convertedPaths","pathDecomposed","unshift","ensureBatExtension","endsWith","scriptLocation","scriptLocationIsAbsolutePath","scriptLocationConverted","EOL","compact","last","isAbsolute","linkLocation","encoding","offset","Buffer","alloc","fd","count","position","wrapFsFunc","fnName","fn","pathArgIndices","j","cacheKey","cached","cache","withCacheSlot","getValue","strings","allStrings","every","arg","result","dirty","finalResult","modifyReturnValue","withValue","wrapDestructiveFsFunc","readFileSync","fileData","wrappedCopyFile","copyFileSync","flags","wrappedRename","renameSync","osTo","startTimeMs","intervalMs","timeLimitMs","attempt","setTimeout","catch","realpathSync","readdirSync","withFileTypes","appendFileSync","chmodSync","closeSync","lstatSync","mkdirSync","openSync","readSync","readlinkSync","rmdirSync","statSync","symlinkSync","unlinkSync","writeSync","writeFileSync","listener"],"sourceRoot":"","sources":["tools/fs/files.ts"],"sourcesContent":["///\n/// utility functions for files and directories. includes both generic\n/// helper functions (such as rm_recursive), and meteor-specific ones\n/// (such as testing whether an directory is a meteor app)\n///\n\nimport fs, { PathLike, Stats, Dirent } from \"fs\";\nimport os from \"os\";\nimport { execFile } from \"child_process\";\nimport { EventEmitter } from \"events\";\nimport { Slot } from \"@wry/context\";\nimport { dep } from \"optimism\";\n\nconst _ = require('underscore');\nconst Fiber = require(\"fibers\");\n\nconst rimraf = require('rimraf');\nconst sourcemap = require('source-map');\nconst sourceMapRetrieverStack = require('../tool-env/source-map-retriever-stack.js');\n\nconst utils = require('../utils/utils.js');\nconst cleanup = require('../tool-env/cleanup.js');\nconst buildmessage = require('../utils/buildmessage.js');\nconst fiberHelpers = require('../utils/fiber-helpers.js');\nconst colonConverter = require('../utils/colon-converter.js');\n\nconst Profile = require('../tool-env/profile').Profile;\n\nexport * from '../static-assets/server/mini-files';\nimport {\n  convertToOSPath,\n  convertToPosixPath,\n  convertToStandardLineEndings,\n  convertToStandardPath,\n  convertToWindowsPath,\n  isWindowsLikeFilesystem,\n  pathBasename,\n  pathDirname,\n  pathJoin,\n  pathNormalize,\n  pathOsDelimiter,\n  pathRelative,\n  pathResolve,\n  pathSep,\n} from \"../static-assets/server/mini-files\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst parsedSourceMaps: Record<string, any> = {};\nlet nextStackFilenameCounter = 1;\n\n// Use the source maps specified to runJavaScript\nfunction useParsedSourceMap(pathForSourceMap: string) {\n  // Check our fancy source map data structure, used for isopacks\n  if (hasOwnProperty.call(parsedSourceMaps, pathForSourceMap)) {\n    return {map: parsedSourceMaps[pathForSourceMap]};\n  }\n\n  return null;\n}\n\n// Try this source map first\nsourceMapRetrieverStack.push(useParsedSourceMap);\n\nfunction canYield() {\n  return Fiber.current &&\n    Fiber.yield &&\n    ! Fiber.yield.disallowed;\n}\n\n// given a predicate function and a starting path, traverse upwards\n// from the path until we find a path that satisfies the predicate.\n//\n// returns either the path to the lowest level directory that passed\n// the test or null for none found. if starting path isn't given, use\n// cwd.\nfunction findUpwards(\n  predicate: (path: string) => boolean,\n  startPath: string = cwd(),\n): string | null {\n  let testDir: string | null = startPath;\n  while (testDir) {\n    if (predicate(testDir)) {\n      break;\n    }\n    var newDir: string = pathDirname(testDir);\n    if (newDir === testDir) {\n      testDir = null;\n    } else {\n      testDir = newDir;\n    }\n  }\n  return testDir || null;\n}\n\nexport function cwd() {\n  return convertToStandardPath(process.cwd());\n}\n\n// Determine if 'filepath' (a path, or omit for cwd) is within an app\n// directory. If so, return the top-level app directory.\nexport function findAppDir(filepath: string) {\n  return findUpwards(function isAppDir(filepath) {\n    // XXX once we are done with the transition to engine, this should\n    // change to: `return exists(path.join(filepath, '.meteor',\n    // 'release'))`\n\n    // .meteor/packages can be a directory, if .meteor is a warehouse\n    // directory.  since installing meteor initializes a warehouse at\n    // $HOME/.meteor, we want to make sure your home directory (and all\n    // subdirectories therein) don't count as being within a meteor app.\n    try { // use try/catch to avoid the additional syscall to exists\n      return stat(\n        pathJoin(filepath, '.meteor', 'packages')).isFile();\n    } catch (e) {\n      return false;\n    }\n  }, filepath);\n}\n\nexport function findPackageDir(filepath: string) {\n  return findUpwards(function isPackageDir(filepath) {\n    try {\n      return stat(pathJoin(filepath, 'package.js')).isFile();\n    } catch (e) {\n      return false;\n    }\n  }, filepath);\n}\n\n// Returns the hash of the current Git HEAD revision of the application,\n// if possible. Always resolves rather than rejecting (unless something\n// truly unexpected happens). The result value is a string when a Git\n// revision was successfully resolved, or undefined otherwise.\nexport function findGitCommitHash(path: string) {\n  return new Promise<string|void>(resolve => {\n    const appDir = findAppDir(path);\n    if (appDir) {\n      execFile(\"git\", [\"rev-parse\", \"HEAD\"], {\n        cwd: convertToOSPath(appDir),\n      }, (error: any, stdout: string) => {\n        if (! error && typeof stdout === \"string\") {\n          resolve(stdout.trim());\n        } else {\n          resolve();\n        }\n      });\n    } else {\n      resolve();\n    }\n  }).await();\n}\n\n// create a .gitignore file in dirPath if one doesn't exist. add\n// 'entry' to the .gitignore on its own line at the bottom of the\n// file, if the exact line does not already exist in the file.\nexport function addToGitignore(dirPath: string, entry: string) {\n  const filePath = pathJoin(dirPath, \".gitignore\");\n  if (exists(filePath)) {\n    let data = readFile(filePath, 'utf8') as string;\n    const lines = data.split(/\\n/);\n    if (lines.some(line => line === entry)) {\n      // already there do nothing\n    } else {\n      // rewrite file w/ new entry.\n      if (data.substr(-1) !== \"\\n\") {\n        data = data + \"\\n\";\n      }\n      data = data + entry + \"\\n\";\n      writeFile(filePath, data, 'utf8');\n    }\n  } else {\n    // doesn't exist, just write it.\n    writeFile(filePath, entry + \"\\n\", 'utf8');\n  }\n}\n\n// Are we running Meteor from a git checkout?\nexport const inCheckout = _.once(function () {\n  try {\n    if (exists(pathJoin(getCurrentToolsDir(), '.git'))) {\n      return true;\n    }\n  } catch (e) { console.log(e); }\n\n  return false;\n});\n\n// True if we are using a warehouse: either installed Meteor, or if\n// $METEOR_WAREHOUSE_DIR is set. Otherwise false (we're in a git checkout and\n// just using packages from the checkout).\nexport function usesWarehouse() {\n  // Test hook: act like we're \"installed\" using a non-homedir warehouse\n  // directory.\n  if (process.env.METEOR_WAREHOUSE_DIR) {\n    return true;\n  } else {\n    return ! inCheckout();\n  }\n}\n\n// Read the '.tools_version.txt' file. If in a checkout, throw an error.\nexport function getToolsVersion() {\n  if (! inCheckout()) {\n    const isopackJsonPath = pathJoin(getCurrentToolsDir(),\n      '..',  // get out of tool, back to package\n      'isopack.json');\n\n    let parsed;\n\n    if (exists(isopackJsonPath)) {\n      // XXX \"isopack-1\" is duplicate of isopack.currentFormat\n      parsed = JSON.parse(readFile(isopackJsonPath))[\"isopack-1\"];\n      return parsed.name + '@' + parsed.version;\n    }\n\n    // XXX COMPAT WITH 0.9.3\n    const unipackageJsonPath = pathJoin(\n      getCurrentToolsDir(),\n      '..',  // get out of tool, back to package\n      'unipackage.json'\n    );\n    parsed = JSON.parse(readFile(unipackageJsonPath));\n    return parsed.name + '@' + parsed.version;\n  } else {\n    throw new Error(\"Unexpected. Git checkouts don't have tools versions.\");\n  }\n}\n\n// Return the root of dev_bundle (probably /usr/local/meteor in an\n// install, or (checkout root)/dev_bundle in a checkout.).\nexport function getDevBundle() {\n  return pathJoin(getCurrentToolsDir(), 'dev_bundle');\n}\n\nexport function getCurrentNodeBinDir() {\n  return pathJoin(getDevBundle(), \"bin\");\n}\n\n// Return the top-level directory for this meteor install or checkout\nexport function getCurrentToolsDir() {\n  return pathDirname(pathDirname(convertToStandardPath(__dirname)));\n}\n\n// Read a settings file and sanity-check it. Returns a string on\n// success or null on failure (in which case buildmessages will be\n// emitted).\nexport function getSettings(\n  filename: string,\n  watchSet: import(\"./watch\").WatchSet,\n) {\n  buildmessage.assertInCapture();\n  const absPath = pathResolve(filename);\n  const buffer = require(\"./watch\").readAndWatchFile(watchSet, absPath);\n  if (buffer === null) {\n    buildmessage.error(\"file not found (settings file)\",\n                       { file: filename });\n    return null;\n  }\n\n  if (buffer.length > 0x10000) {\n    buildmessage.error(\"settings file is too large (must be less than 64k)\",\n                       { file: filename });\n    return null;\n  }\n\n  let str = buffer.toString('utf8');\n\n  // The use of a byte order mark crashes JSON parsing. Since a BOM is not\n  // required (or recommended) when using UTF-8, let's remove it if it exists.\n  str = str.charCodeAt(0) === 0xFEFF ? str.slice(1) : str;\n\n  // Ensure that the string is parseable in JSON, but there's no reason to use\n  // the object value of it yet.\n  if (str.match(/\\S/)) {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      buildmessage.error(\"parse error reading settings file\",\n                         { file: filename });\n    }\n  }\n\n  return str;\n}\n\n// Returns true if the first path is a parent of the second path\nexport function containsPath(path1: string, path2: string) {\n  const relPath = pathRelative(path1, path2);\n\n  // On Windows, if the two paths are on different drives the relative\n  // path starts with /\n  return !(relPath.startsWith(\"..\") || relPath.startsWith(\"/\"));\n}\n\n// Try to find the prettiest way to present a path to the\n// user. Presently, the main thing it does is replace $HOME with ~.\nexport function prettyPath(p: string) {\n  p = realpath(p);\n  const home = getHomeDir();\n  if (! home) {\n    return p;\n  }\n  const relativeToHome = pathRelative(home, p);\n  if (relativeToHome.substr(0, 3) === ('..' + pathSep)) {\n    return p;\n  }\n  return pathJoin('~', relativeToHome);\n}\n\n// Like statSync, but null if file not found\nexport function statOrNull(path: string) {\n  return statOrNullHelper(path, false);\n}\n\nfunction statOrNullHelper(path: string, preserveSymlinks = false) {\n  try {\n    return preserveSymlinks\n      ? lstat(path)\n      : stat(path);\n  } catch (e) {\n    if (e.code === \"ENOENT\") {\n      return null;\n    }\n    throw e;\n  }\n}\n\nexport function realpathOrNull(path: string) {\n  try {\n    return realpath(path);\n  } catch (e) {\n    if (e.code !== \"ENOENT\") throw e;\n    return null;\n  }\n}\n\nexport function rm_recursive_async(path: string) {\n  return new Promise<void>((resolve, reject) => {\n    rimraf(convertToOSPath(path), (err: Error) => err\n      ? reject(err)\n      : resolve());\n  });\n}\n\n// Like rm -r.\nexport const rm_recursive = Profile(\"files.rm_recursive\", (path: string) => {\n  try {\n    rimraf.sync(convertToOSPath(path));\n  } catch (e) {\n    if ((e.code === \"ENOTEMPTY\" ||\n         e.code === \"EPERM\") &&\n        canYield()) {\n      rm_recursive_async(path).await();\n      return;\n    }\n    throw e;\n  }\n});\n\n// Returns the base64 SHA256 of the given file.\nexport function fileHash(filename: string) {\n  const crypto = require('crypto');\n  const hash = crypto.createHash('sha256');\n  hash.setEncoding('base64');\n  const rs = createReadStream(filename);\n  return new Promise(function (resolve) {\n    rs.on('end', function () {\n      rs.close();\n      resolve(hash.digest('base64'));\n    });\n    rs.pipe(hash, { end: false });\n  }).await();\n}\n\n// This is the result of running fileHash on a blank file.\nexport const blankHash = \"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\";\n\n// Returns a base64 SHA256 hash representing a tree on disk. It is not sensitive\n// to modtime, uid/gid, or any permissions bits other than the current-user-exec\n// bit on normal files.\nexport function treeHash(root: string, optionsParams: {\n  ignore?: (path: string) => boolean;\n}) {\n  const options = {\n    ignore() { return false; },\n    ...optionsParams,\n  };\n\n  const hash = require('crypto').createHash('sha256');\n\n  function traverse(relativePath: string) {\n    if (options.ignore(relativePath)) {\n      return;\n    }\n\n    var absPath = pathJoin(root, relativePath);\n    var stat = lstat(absPath);\n\n    if (stat?.isDirectory()) {\n      if (relativePath) {\n        hash.update('dir ' + JSON.stringify(relativePath) + '\\n');\n      }\n      readdir(absPath).forEach(entry => {\n        traverse(pathJoin(relativePath, entry));\n      });\n    } else if (stat?.isFile()) {\n      if (!relativePath) {\n        throw Error(\"must call files.treeHash on a directory\");\n      }\n      hash.update('file ' + JSON.stringify(relativePath) + ' ' +\n                  stat?.size + ' ' + fileHash(absPath) + '\\n');\n\n      // @ts-ignore\n      if (stat.mode & 0o100) {\n        hash.update('exec\\n');\n      }\n    } else if (stat?.isSymbolicLink()) {\n      if (!relativePath) {\n        throw Error(\"must call files.treeHash on a directory\");\n      }\n      hash.update('symlink ' + JSON.stringify(relativePath) + ' ' +\n                  JSON.stringify(readlink(absPath)) + '\\n');\n    }\n    // ignore anything weirder\n  }\n\n  traverse('');\n\n  return hash.digest('base64');\n}\n\n// like mkdir -p. if it returns true, the item is a directory (even if\n// it was already created). if it returns false, the item is not a\n// directory and we couldn't make it one.\nexport function mkdir_p(dir: string, mode: number | null = null) {\n  const p = pathResolve(dir);\n  const ps = pathNormalize(p).split(pathSep);\n\n  const stat = statOrNull(p);\n  if (stat) {\n    return stat.isDirectory();\n  }\n\n  // doesn't exist. recurse to build parent.\n  // Don't use pathJoin here because it can strip off the leading slash\n  // accidentally.\n  const parentPath = ps.slice(0, -1).join(pathSep);\n  const success = mkdir_p(parentPath, mode);\n  // parent is not a directory.\n  if (! success) { return false; }\n\n  try {\n    mkdir(p, mode);\n  } catch (err) {\n    if (err.code === \"EEXIST\") {\n      if (pathIsDirectory(p)) {\n        // all good, someone else created this directory for us while we were\n        // yielding\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      throw err;\n    }\n  }\n\n  // double check we exist now\n  return pathIsDirectory(p);\n}\n\nfunction pathIsDirectory(path: string) {\n  const stat = statOrNull(path);\n  return stat && stat.isDirectory();\n}\n\n// Roughly like cp -R.\n//\n// The output files will be readable and writable by everyone that the umask\n// allows, and executable by everyone (modulo umask) if the original file was\n// owner-executable. Symlinks are treated transparently (ie the contents behind\n// them are copied, and it's an error if that points nowhere).\n//\n// If options.transform{Filename, Contents} is present, it should\n// be a function, and the contents (as a buffer) or filename will be\n// passed through the function. Use this to, eg, fill templates.\n//\n// If options.ignore is present, it should be a list of regexps. Any\n// file whose basename matches one of the regexps, before\n// transformation, will be skipped.\nexport function cp_r(from: string, to: string, options: {\n  preserveSymlinks?: boolean;\n  ignore?: RegExp[];\n  transformFilename?: (f: string) => string;\n  transformContents?: (\n    contents: ReturnType<typeof readFile>,\n    file: string,\n  ) => typeof contents;\n} = {}) {\n  from = pathResolve(from);\n\n  const stat = statOrNullHelper(from, options.preserveSymlinks);\n  if (! stat) {\n    return;\n  }\n\n  if (stat.isDirectory()) {\n    mkdir_p(to, 0o755);\n\n    readdir(from).forEach(f => {\n      if (options.ignore &&\n          options.ignore.some(pattern => f.match(pattern))) {\n        return;\n      }\n\n      const fullFrom = pathJoin(from, f);\n\n      if (options.transformFilename) {\n        f = options.transformFilename(f);\n      }\n\n      cp_r(\n        fullFrom,\n        pathJoin(to, f),\n        options\n      );\n    })\n\n    return;\n  }\n\n  mkdir_p(pathDirname(to));\n\n  if (stat.isSymbolicLink()) {\n    symlinkWithOverwrite(readlink(from), to);\n\n  } else if (options.transformContents) {\n    writeFile(to, options.transformContents(\n      readFile(from),\n      pathBasename(from)\n    ), {\n      // Create the file as readable and writable by everyone, and\n      // executable by everyone if the original file is executable by\n      // owner. (This mode will be modified by umask.) We don't copy the\n      // mode *directly* because this function is used by 'meteor create'\n      // which is copying from the read-only tools tree into a writable app.\n\n      // @ts-ignore\n      mode: (stat.mode & 0o100) ? 0o777 : 0o666,\n    });\n\n  } else {\n    // Note: files.copyFile applies the same stat.mode logic as above.\n    copyFile(from, to);\n  }\n}\n\n// create a symlink, overwriting the target link, file, or directory\n// if it exists\nexport const symlinkWithOverwrite =\nProfile(\"files.symlinkWithOverwrite\", function symlinkWithOverwrite(\n  source: string,\n  target: string,\n) {\n  const args: [string, string, \"junction\"?] = [source, target];\n\n  if (process.platform === \"win32\") {\n    const absoluteSource = pathResolve(target, source);\n\n    if (stat(absoluteSource).isDirectory()) {\n      args[2] = \"junction\";\n    }\n  }\n\n  try {\n    symlink(...args);\n  } catch (e) {\n    if (e.code === \"EEXIST\") {\n      function normalizePath(path: string) {\n        return convertToOSPath(path).replace(/[\\/\\\\]$/, \"\")\n      }\n\n      if (lstat(target)?.isSymbolicLink() &&\n          normalizePath(readlink(target)) === normalizePath(source)) {\n        // If the target already points to the desired source, we don't\n        // need to do anything.\n        return;\n      }\n      // overwrite existing link, file, or directory\n      rm_recursive(target);\n      symlink(...args);\n    } else {\n      throw e;\n    }\n  }\n})\n\n/**\n * Get every path in a directory recursively, treating symlinks as files\n * @param  {String} dir     The directory to walk, either relative to options.cwd or completely absolute\n * @param  {Object} options Some options\n * @param {String} options.cwd The directory that paths should be relative to\n * @param {String[]} options.output An array to push results to\n * @return {String[]}         All of the paths in the directory recursively\n */\nexport function getPathsInDir(dir: string, options: {\n  cwd?: string;\n  output?: string[];\n}) {\n  // Don't let this function yield so that the file system doesn't get changed\n  // underneath us\n  return fiberHelpers.noYieldsAllowed(function () {\n    var cwd = options.cwd || convertToStandardPath(process.cwd());\n\n    if (! exists(cwd)) {\n      throw new Error(\"Specified current working directory doesn't exist: \" +\n        cwd);\n    }\n\n    const absoluteDir = pathResolve(cwd, dir);\n\n    if (! exists(absoluteDir)) {\n      // There are no paths in this dir, so don't do anything\n      return;\n    }\n\n    const output = options.output || [];\n\n    function pathIsDirectory(path: string) {\n      var stat = lstat(path);\n      return stat?.isDirectory() || false;\n    }\n\n    readdir(absoluteDir).forEach(entry => {\n      const newPath = pathJoin(dir, entry);\n      const newAbsPath = pathJoin(absoluteDir, entry);\n\n      output.push(newPath);\n\n      if (pathIsDirectory(newAbsPath)) {\n        getPathsInDir(newPath, {\n          cwd: cwd,\n          output: output\n        });\n      }\n    });\n\n    return output;\n  });\n}\n\nexport function findPathsWithRegex(\n  dir: string,\n  regex: RegExp,\n  options: {\n    cwd: string;\n  },\n) {\n  return getPathsInDir(dir, {\n    cwd: options.cwd\n  }).filter(function (path: string) {\n    return path.match(regex);\n  });\n}\n\n// Make a temporary directory. Returns the path to the newly created\n// directory. Only the current user is allowed to read or write the\n// files in the directory (or add files to it). The directory will\n// be cleaned up on exit.\nconst tempDirs = Object.create(null);\nexport function mkdtemp(prefix: string): string {\n  function make(): string {\n    prefix = prefix || 'mt-';\n    // find /tmp\n    let tmpDir: string | undefined;\n    ['TMPDIR', 'TMP', 'TEMP'].some(t => {\n      const value = process.env[t];\n      if (value) {\n        tmpDir = value;\n        return true;\n      }\n    });\n\n    if (! tmpDir && process.platform !== 'win32') {\n      tmpDir = '/tmp';\n    }\n\n    if (! tmpDir) {\n      throw new Error(\"Couldn't create a temporary directory.\");\n    }\n\n    tmpDir = realpath(tmpDir);\n\n    // make the directory. give it 3 tries in case of collisions from\n    // crappy random.\n    var tries = 3;\n    while (tries > 0) {\n      const dirPath = pathJoin(\n        tmpDir,\n        prefix + (Math.random() * 0x100000000 + 1).toString(36),\n      );\n      try {\n        mkdir(dirPath, 0o700);\n        return dirPath;\n      } catch (err) {\n        tries--;\n      }\n    }\n    throw new Error(\"failed to make temporary directory in \" + tmpDir);\n  };\n  const dir = make();\n  tempDirs[dir] = true;\n  return dir;\n}\n\n// Call this if you're done using a temporary directory. It will asynchronously\n// be deleted.\nexport function freeTempDir(dir: string) {\n  if (! tempDirs[dir]) {\n    throw Error(\"not a tracked temp dir: \" + dir);\n  }\n\n  if (process.env.METEOR_SAVE_TMPDIRS) {\n    return;\n  }\n\n  return rm_recursive_async(dir).then(() => {\n    // Delete tempDirs[dir] only when the removal finishes, so that the\n    // cleanup.onExit handler can attempt the removal synchronously if it\n    // fires in the meantime.\n    delete tempDirs[dir];\n  }, error => {\n    // Leave tempDirs[dir] in place so the cleanup.onExit handler can try\n    // to delete it again when the process exits.\n    console.log(error);\n  });\n}\n\n// Change the status of a dir\nexport function changeTempDirStatus(dir: string, status: boolean) {\n  if (! tempDirs[dir]) {\n    throw Error(\"not a tracked temp dir: \" + dir);\n  }\n\n  tempDirs[dir] = status;\n}\n\nif (! process.env.METEOR_SAVE_TMPDIRS) {\n  cleanup.onExit(function () {\n    Object.entries(tempDirs).filter(([_, isTmp]) => !!isTmp).map(([dir]) => dir).forEach(dir => {\n      delete tempDirs[dir];\n      try {\n        rm_recursive(dir);\n      } catch (err) {\n        // Don't crash and print a stack trace because we failed to delete\n        // a temp directory. This happens sometimes on Windows and seems\n        // to be unavoidable.\n      }\n    });\n  });\n}\n\ntype TarOptions = {\n  verbose?: boolean;\n  forceConvert?: boolean;\n}\n\n// Takes a buffer containing `.tar.gz` data and extracts the archive\n// into a destination directory. destPath should not exist yet, and\n// the archive should contain a single top-level directory, which will\n// be renamed atomically to destPath.\nexport function extractTarGz(\n  buffer: Buffer,\n  destPath: string,\n  options: TarOptions = {},\n) {\n  const parentDir = pathDirname(destPath);\n  const tempDir = pathJoin(parentDir, '.tmp' + utils.randomToken());\n  mkdir_p(tempDir);\n\n  if (! hasOwnProperty.call(options, \"verbose\")) {\n    options.verbose = require(\"../console/console.js\").Console.verbose;\n  }\n\n  const startTime = +new Date;\n\n  // standardize only one way of extracting, as native ones can be tricky\n  const promise = tryExtractWithNpmTar(buffer, tempDir, options)\n\n  promise.await();\n\n  // succeed!\n  const topLevelOfArchive = readdir(tempDir)\n    // On Windows, the 7z.exe tool sometimes creates an auxiliary\n    // PaxHeader directory.\n    .filter(file => ! file.startsWith(\"PaxHeader\"));\n\n  if (topLevelOfArchive.length !== 1) {\n    throw new Error(\n      \"Extracted archive '\" + tempDir + \"' should only contain one entry\");\n  }\n\n  const extractDir = pathJoin(tempDir, topLevelOfArchive[0]);\n  rename(extractDir, destPath);\n  rm_recursive(tempDir);\n\n  if (options.verbose) {\n    console.log(\"Finished extracting in\", Date.now() - startTime, \"ms\");\n  }\n}\n\nfunction ensureDirectoryEmpty(dir: string) {\n  readdir(dir).forEach(file => {\n    rm_recursive(pathJoin(dir, file));\n  });\n}\n\nfunction tryExtractWithNpmTar(\n  buffer: Buffer,\n  tempDir: string,\n  options: TarOptions = {},\n) {\n  ensureDirectoryEmpty(tempDir);\n\n  const tar = require(\"tar-fs\");\n  const zlib = require(\"zlib\");\n\n  return new Promise((resolve, reject) => {\n    const gunzip = zlib.createGunzip().on('error', reject);\n    const extractor = tar.extract(convertToOSPath(tempDir), {\n      /* the following lines guarantees that archives created on windows\n      are going to be readable and writable on unixes */\n      readable: true, // all dirs and files should be readable\n      writable: true, // all dirs and files should be writable\n      map: function(header: any) {\n        if (process.platform === \"win32\" || options.forceConvert) {\n          // On Windows, try to convert old packages that have colons in\n          // paths by blindly replacing all of the paths. Otherwise, we\n          // can't even extract the tarball\n          header.name = colonConverter.convert(header.name);\n        }\n        return header\n      }\n    }).on('error', reject)\n      .on('finish', resolve);\n\n    // write the buffer to the (gunzip|untar) pipeline; these calls\n    // cause the tar to be extracted to disk.\n    gunzip.pipe(extractor);\n    gunzip.write(buffer);\n    gunzip.end();\n  });\n}\n\n// In the same fashion as node-pre-gyp does, add the executable\n// bit but only if the read bit was present.  Same as:\n// https://github.com/mapbox/node-pre-gyp/blob/7a28f4b0f562ba4712722fefe4eeffb7b20fbf7a/lib/install.js#L71-L77\n// and others reported in: https://github.com/npm/node-tar/issues/7\nfunction addExecBitWhenReadBitPresent(fileMode: number) {\n  return fileMode |= (fileMode >>> 2) & 0o111;\n}\n\n// Tar-gzips a directory, returning a stream that can then be piped as\n// needed.  The tar archive will contain a top-level directory named\n// after dirPath.\nexport function createTarGzStream(dirPath: string) {\n  const tar = require(\"tar-fs\");\n  const zlib = require(\"zlib\");\n  const basename = pathBasename(dirPath);\n\n  // Create a segment of the file path which we will look for to\n  // identify exactly what we think is a \"bin\" file (that is, something\n  // which should be expected to work within the context of an\n  // 'npm run-script').\n  // tar-fs doesn't use native paths in the header, so we are joining with a slash\n  const binPathMatch = [\"\", \"node_modules\", \".bin\", \"\"].join('/');\n  const tarStream = tar.pack(convertToOSPath(dirPath), {\n    map: (header: any) => {\n      header.name = `${basename}/${header.name}`\n\n      if (process.platform !== \"win32\") {\n        return header;\n      }\n\n      if (header.type === \"directory\") {\n        header.mode = addExecBitWhenReadBitPresent(header.mode);\n      }\n\n      if (header.type === \"file\" && header.name.includes(binPathMatch)) {\n        header.mode = addExecBitWhenReadBitPresent(header.mode);\n      }\n      return header\n    },\n    readable: true, // all dirs and files should be readable\n    writable: true, // all dirs and files should be writable\n  });\n\n  return tarStream.pipe(zlib.createGzip());\n}\n\n// Tar-gzips a directory into a tarball on disk, synchronously.\n// The tar archive will contain a top-level directory named after dirPath.\nexport const createTarball = Profile(function (_: string, tarball: string) {\n  return \"files.createTarball \" + pathBasename(tarball);\n}, function (dirPath: string, tarball: string) {\n  const out = createWriteStream(tarball);\n  new Promise(function (resolve, reject) {\n    out.on('error', reject);\n    out.on('close', resolve);\n    createTarGzStream(dirPath).pipe(out);\n  }).await();\n});\n\n// Use this if you'd like to replace a directory with another\n// directory as close to atomically as possible. It's better than\n// recursively deleting the target directory first and then\n// renaming. (Failure modes here include \"there's a brief moment where\n// toDir does not exist\" and \"you can end up with garbage directories\n// sitting around\", but not \"there's any time where toDir exists but\n// is in a state other than initial or final\".)\nexport const renameDirAlmostAtomically =\nProfile(\"files.renameDirAlmostAtomically\", (fromDir: string, toDir: string) => {\n  const garbageDir = pathJoin(\n    pathDirname(toDir),\n    // Begin the base filename with a '.' character so that it can be\n    // ignored by other directory-scanning code.\n    `.${pathBasename(toDir)}-garbage-${utils.randomToken()}`,\n  );\n\n  // Get old dir out of the way, if it exists.\n  let cleanupGarbage = false;\n  let forceCopy = false;\n  try {\n    rename(toDir, garbageDir);\n    cleanupGarbage = true;\n  } catch (e) {\n    if (e.code === 'EXDEV') {\n      // Some (notably Docker) file systems will fail to do a seemingly\n      // harmless operation, such as renaming, on what is apparently the same\n      // file system.  AUFS will do this even if the `fromDir` and `toDir`\n      // are on the same layer, and OverlayFS will fail if the `fromDir` and\n      // `toDir` are on different layers.  In these cases, we will not be\n      // atomic and will need to do a recursive copy.\n      forceCopy = true;\n    } else if (e.code !== 'ENOENT') {\n      // No such file or directory is okay, but anything else is not.\n      throw e;\n    }\n  }\n\n  if (! forceCopy) {\n    try {\n      rename(fromDir, toDir);\n    } catch (e) {\n      // It's possible that there may not have been a `toDir` to have\n      // advanced warning about this, so we're prepared to handle it again.\n      if (e.code === 'EXDEV') {\n        forceCopy = true;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // If we've been forced to jeopardize our atomicity due to file-system\n  // limitations, we'll resort to copying.\n  if (forceCopy) {\n    rm_recursive(toDir);\n    cp_r(fromDir, toDir, {\n      preserveSymlinks: true,\n    });\n  }\n\n  // ... and take out the trash.\n  if (cleanupGarbage) {\n    // We don't care about how long this takes, so we'll let it go async.\n    rm_recursive_async(garbageDir);\n  }\n});\n\nexport const writeFileAtomically =\nProfile(\"files.writeFileAtomically\", function (filename: string, contents: string | Buffer) {\n  const parentDir = pathDirname(filename);\n  mkdir_p(parentDir);\n\n  const tmpFile = pathJoin(\n    parentDir,\n    '.' + pathBasename(filename) + '.' + utils.randomToken()\n  );\n\n  writeFile(tmpFile, contents);\n  rename(tmpFile, filename);\n});\n\n// Like fs.symlinkSync, but creates a temporay link and renames it over the\n// file; this means it works even if the file already exists.\n// Do not use this function on Windows, it won't work.\nexport function symlinkOverSync(linkText: string, file: string) {\n  file = pathResolve(file);\n  const tmpSymlink = pathJoin(\n    pathDirname(file),\n    \".\" + pathBasename(file) + \".tmp\" + utils.randomToken());\n  symlink(linkText, tmpSymlink);\n  rename(tmpSymlink, file);\n}\n\n// Return the result of evaluating `code` using\n// `runInThisContext`. `code` will be wrapped in a closure. You can\n// pass additional values to bind in the closure in `options.symbols`,\n// the keys being the symbols to bind and the values being their\n// values. `options.filename` is the filename to use in exceptions\n// that come from inside this code. `options.sourceMap` is an optional\n// source map that represents the file.\n//\n// The really special thing about this function is that if a parse\n// error occurs, we will raise an exception of type\n// files.FancySyntaxError, from which you may read 'message', 'file',\n// 'line', and 'column' attributes ... v8 is normally reluctant to\n// reveal this information but will write it to stderr if you pass it\n// an undocumented flag. Unforunately though node doesn't have dup2 so\n// we can't intercept the write. So instead we use a completely\n// different parser with a better error handling API. Ah well.  The\n// underlying V8 issue is:\n//   https://code.google.com/p/v8/issues/detail?id=1281\nexport function runJavaScript(code: string, {\n  symbols = Object.create(null),\n  filename = \"<anonymous>\",\n  sourceMap,\n  sourceMapRoot,\n}: {\n  symbols: Record<string, any>;\n  filename: string;\n  sourceMap?: object;\n  sourceMapRoot?: string;\n}) {\n  return Profile.time('runJavaScript ' + filename, () => {\n    const keys: string[] = [], values: any[] = [];\n    // don't assume that _.keys and _.values are guaranteed to\n    // enumerate in the same order\n    _.each(symbols, function (value: any, name: string) {\n      keys.push(name);\n      values.push(value);\n    });\n\n    let stackFilename = filename;\n    if (sourceMap) {\n      // We want to generate an arbitrary filename that we use to associate the\n      // file with its source map.\n      stackFilename = \"<runJavaScript-\" + nextStackFilenameCounter++ + \">\";\n    }\n\n    const chunks = [];\n    const header = \"(function(\" + keys.join(',') + \"){\";\n    chunks.push(header);\n    if (sourceMap) {\n      const sourcemapConsumer = Promise.await(new sourcemap.SourceMapConsumer(sourceMap));\n      chunks.push(sourcemap.SourceNode.fromStringWithSourceMap(\n        code, sourcemapConsumer));\n      sourcemapConsumer.destroy();\n    } else {\n      chunks.push(code);\n    }\n    // \\n is necessary in case final line is a //-comment\n    chunks.push(\"\\n})\");\n\n    let wrapped;\n    let parsedSourceMap = null;\n    if (sourceMap) {\n      const results = new sourcemap.SourceNode(\n        null, null, null, chunks\n      ).toStringWithSourceMap({\n        file: stackFilename\n      });\n      wrapped = results.code;\n      parsedSourceMap = results.map.toJSON();\n      if (sourceMapRoot) {\n        // Add the specified root to any root that may be in the file.\n        parsedSourceMap.sourceRoot = pathJoin(\n          sourceMapRoot, parsedSourceMap.sourceRoot || '');\n      }\n      // source-map-support doesn't ever look at the sourcesContent field, so\n      // there's no point in keeping it in memory.\n      delete parsedSourceMap.sourcesContent;\n      parsedSourceMaps[stackFilename] = parsedSourceMap;\n    } else {\n      wrapped = chunks.join('');\n    };\n\n    try {\n      // See #runInThisContext\n      //\n      // XXX it'd be nice to runInNewContext so that the code can't mess\n      // with our globals, but objects that come out of runInNewContext\n      // have bizarro antimatter prototype chains and break 'instanceof\n      // Array'. for now, steer clear\n      //\n      // Pass 'true' as third argument if we want the parse error on\n      // stderr (which we don't).\n      var script = require('vm').createScript(wrapped, stackFilename);\n    } catch (nodeParseError) {\n      if (!(nodeParseError instanceof SyntaxError)) {\n        throw nodeParseError;\n      }\n      // Got a parse error. Unfortunately, we can't actually get the\n      // location of the parse error from the SyntaxError; Node has some\n      // hacky support for displaying it over stderr if you pass an\n      // undocumented third argument to stackFilename, but that's not\n      // what we want. See\n      //    https://github.com/joyent/node/issues/3452\n      // for more information. One thing to try (and in fact, what an\n      // early version of this function did) is to actually fork a new\n      // node to run the code and parse its output. We instead run an\n      // entirely different JS parser, from the Babel project, but\n      // which at least has a nice API for reporting errors.\n      const { parse } = require('@meteorjs/babel');\n      try {\n        parse(wrapped, { strictMode: false });\n      } catch (parseError) {\n        if (typeof parseError.loc !== \"object\") {\n          throw parseError;\n        }\n\n        const err = new FancySyntaxError;\n        err.message = parseError.message;\n\n        if (parsedSourceMap) {\n          // XXX this duplicates code in computeGlobalReferences\n          var consumer2 = Promise.await(new sourcemap.SourceMapConsumer(parsedSourceMap));\n          var original = consumer2.originalPositionFor(parseError.loc);\n          consumer2.destroy();\n          if (original.source) {\n            err.file = original.source;\n            err.line = original.line;\n            err.column = original.column;\n            throw err;\n          }\n        }\n\n        err.file = filename;  // *not* stackFilename\n        err.line = parseError.loc.line;\n        err.column = parseError.loc.column;\n\n        // adjust errors on line 1 to account for our header\n        if (err.line === 1 && typeof err.column === \"number\") {\n          err.column -= header.length;\n        }\n\n        throw err;\n      }\n\n      // What? Node thought that this was a parse error and Babel didn't?\n      // Eh, just throw Node's error and don't care too much about the line\n      // numbers being right.\n      throw nodeParseError;\n    }\n\n    return buildmessage.markBoundary(\n      script.runInThisContext()\n    ).apply(null, values);\n  });\n}\n\n// - message: an error message from the parser\n// - file: filename\n// - line: 1-based\n// - column: 1-based\nexport class FancySyntaxError {\n  public file?: string;\n  public line?: number;\n  public column?: number;\n  constructor(public message?: string) {}\n}\n\nexport class OfflineError {\n  constructor(public error: Error) {}\n  toString() {\n    return \"[Offline: \" + this.error.toString() + \"]\";\n  }\n}\n\n// Like files.readdir, but skips entries whose names begin with dots, and\n// converts ENOENT to [].\nexport function readdirNoDots(path: string) {\n  try {\n    var entries = readdir(path);\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return [];\n    }\n    throw e;\n  }\n  return entries.filter(entry => {\n    return entry && entry[0] !== '.';\n  });\n}\n\n// Read a file in line by line. Returns an array of lines to be\n// processed individually. Throws if the file doesn't exist or if\n// anything else goes wrong.\nexport function getLines(file: string) {\n  var buffer = readFile(file);\n  var lines = exports.splitBufferToLines(buffer);\n\n  // strip blank lines at the end\n  while (lines.length) {\n    var line = lines[lines.length - 1];\n    if (line.match(/\\S/)) {\n      break;\n    }\n    lines.pop();\n  }\n\n  return lines;\n}\n\nexport function splitBufferToLines(buffer: Buffer) {\n  return buffer.toString('utf8').split(/\\r*\\n\\r*/);\n}\n\n// Same as `getLines`, but returns [] if the file doesn't exist.\nexport function getLinesOrEmpty(file: string) {\n  try {\n    return getLines(file);\n  } catch (e) {\n    if (e && e.code === 'ENOENT') {\n      return [];\n    }\n    throw e;\n  }\n}\n\n// Returns null if the file does not exist, otherwise returns the parsed JSON in\n// the file. Throws on errors other than ENOENT (including JSON parse failure).\nexport function readJSONOrNull(file: string) {\n  try {\n    var raw = readFile(file, 'utf8');\n  } catch (e) {\n    if (e && e.code === 'ENOENT') {\n      return null;\n    }\n    throw e;\n  }\n  return JSON.parse(raw);\n}\n\n// Trims whitespace & other filler characters of a line in a project file.\nexport function trimSpaceAndComments(line: string) {\n  var match = line.match(/^([^#]*)#/);\n  if (match) {\n    line = match[1];\n  }\n  return trimSpace(line);\n}\n\n// Trims leading and trailing whilespace in a project file.\nexport function trimSpace(line: string) {\n  return line.replace(/^\\s+|\\s+$/g, '');\n}\n\nexport class KeyValueFile {\n  constructor(public path: string) {}\n\n  set(k: string, v: any) {\n    const data = (this.readAll() || '').toString(\"utf8\");\n    const lines = data.split(/\\n/);\n\n    let found = false;\n    for (let i = 0; i < lines.length; i++) {\n      const trimmed = lines[i].trim();\n      if (trimmed.indexOf(k + '=') == 0) {\n        lines[i] = k + '=' + v;\n        found = true;\n      }\n    }\n    if (!found) {\n      lines.push(k + \"=\" + v);\n    }\n    const newdata = lines.join('\\n') + '\\n';\n    writeFile(this.path, newdata, 'utf8');\n  }\n\n  private readAll() {\n    if (exists(this.path)) {\n      return readFile(this.path, 'utf8');\n    } else {\n      return null;\n    }\n  }\n}\n\nexport function getHomeDir() {\n  if (process.platform === \"win32\") {\n    const MI = process.env.METEOR_INSTALLATION;\n    if (typeof MI === \"string\") {\n      return pathDirname(convertToStandardPath(MI));\n    }\n  }\n  return process.env.HOME;\n}\n\nexport function currentEnvWithPathsAdded(...paths: string[]) {\n  const env = {...process.env};\n\n  let pathPropertyName;\n  if (process.platform === \"win32\") {\n    // process.env allows for case insensitive access on Windows, but copying it\n    // creates a normal JavaScript object with case sensitive property access.\n    // This leads to problems, because we would be adding a PATH property instead\n    // of setting Path for instance.\n    // We want to make sure we're setting the right property, so we\n    // lookup the property name case insensitively ourselves.\n    pathPropertyName = _.find(Object.keys(env), (key: string) => {\n      return key.toUpperCase() === 'PATH';\n    });\n    if (!pathPropertyName) {\n      pathPropertyName = 'Path';\n    }\n  } else {\n    pathPropertyName = 'PATH';\n  }\n\n  const convertedPaths = paths.map(path => convertToOSPath(path));\n  let pathDecomposed = (env[pathPropertyName] || \"\").split(pathOsDelimiter);\n  pathDecomposed.unshift(...convertedPaths);\n\n  env[pathPropertyName] = pathDecomposed.join(pathOsDelimiter);\n  return env;\n}\n\n// add .bat extension to link file if not present\nfunction ensureBatExtension(p: string) {\n  return p.endsWith(\".bat\") ? p : p + \".bat\";\n}\n\n// Windows-only, generates a bat script that calls the destination bat script\nexport function _generateScriptLinkToMeteorScript(scriptLocation: string) {\n  const scriptLocationIsAbsolutePath = scriptLocation.match(/^\\//);\n  const scriptLocationConverted = scriptLocationIsAbsolutePath\n    ? convertToWindowsPath(scriptLocation)\n    : \"%~dp0\\\\\" + convertToWindowsPath(scriptLocation);\n\n  return [\n    \"@echo off\",\n    \"SETLOCAL\",\n    \"SET METEOR_INSTALLATION=%~dp0%\",\n\n    // always convert to Windows path since this function can also be\n    // called on Linux or Mac when we are building bootstrap tarballs\n    \"\\\"\" + scriptLocationConverted + \"\\\" %*\",\n    \"ENDLOCAL\",\n\n    // always exit with the same exit code as the child script\n    \"EXIT /b %ERRORLEVEL%\",\n\n    // add a comment with the destination of the link, so it can be read later\n    // by files.readLinkToMeteorScript\n    \"rem \" + scriptLocationConverted,\n  ].join(os.EOL);\n}\n\nexport function _getLocationFromScriptLinkToMeteorScript(script: string | Buffer) {\n  const lines = _.compact(script.toString().split('\\n'));\n\n  let scriptLocation = _.last(lines).replace(/^rem /g, '');\n  let isAbsolute = true;\n\n  if (scriptLocation.match(/^%~dp0/)) {\n    isAbsolute = false;\n    scriptLocation = scriptLocation.replace(/^%~dp0\\\\?/g, '');\n  }\n\n  if (! scriptLocation) {\n    throw new Error('Failed to parse script location from meteor.bat');\n  }\n\n  return convertToPosixPath(scriptLocation, ! isAbsolute);\n}\n\nexport function linkToMeteorScript(\n  scriptLocation: string,\n  linkLocation: string,\n  platform: string,\n) {\n  platform = platform || process.platform;\n\n  if (platform === 'win32') {\n    // Make a meteor batch script that points to current tool\n    linkLocation = ensureBatExtension(linkLocation);\n    scriptLocation = ensureBatExtension(scriptLocation);\n    const script = _generateScriptLinkToMeteorScript(scriptLocation);\n    writeFile(linkLocation, script, { encoding: \"ascii\" });\n  } else {\n    // Symlink meteor tool\n    symlinkOverSync(scriptLocation, linkLocation);\n  }\n}\n\nexport function readLinkToMeteorScript(\n  linkLocation: string,\n  platform = process.platform,\n) {\n  if (platform === 'win32') {\n    linkLocation = ensureBatExtension(linkLocation);\n    const script = readFile(linkLocation);\n    return _getLocationFromScriptLinkToMeteorScript(script);\n  } else {\n    return readlink(linkLocation);\n  }\n}\n\n// The fs.exists method is deprecated in Node v4:\n// https://nodejs.org/api/fs.html#fs_fs_exists_path_callback\nexport function exists(path: string) {\n  return !! statOrNull(path);\n}\n\nexport function readBufferWithLengthAndOffset(\n  filename: string,\n  length: number,\n  offset: number,\n) {\n  const data = Buffer.alloc(length);\n  // Read the data from disk, if it is non-empty. Avoid doing IO for empty\n  // files, because (a) unnecessary and (b) fs.readSync with length 0\n  // throws instead of acting like POSIX read:\n  // https://github.com/joyent/node/issues/5685\n  if (length > 0) {\n    const fd = open(filename, \"r\");\n    try {\n      const count = read(fd, data, { position: 0, length, offset });\n      if (count !== length) {\n        throw new Error(\"couldn't read entire resource\");\n      }\n    } finally {\n      close(fd);\n    }\n  }\n  return data;\n}\n\n// Summary of cross platform file system handling strategy\n\n// There are three main pain points for handling files on Windows: slashes in\n// paths, line endings in text files, and colons/invalid characters in paths.\n\n// 1. Slashes in file paths\n\n//   We have decided to store all paths inside the tool as unix-style paths in\n//   the style of CYGWIN. This means that all paths have forward slashes on all\n//   platforms, and C:\\ is converted to /c/ on Windows.\n\n//   All of the methods in files.js know how to convert from these unixy paths\n//   to whatever type of path the underlying system prefers.\n\n//   The reason we chose this strategy because it was easier to make sure to use\n//   files.js everywhere instead of node's fs than to make sure every part of\n//   the tool correctly uses system-specific path separators. In addition, there\n//   are some parts of the tool where it is very hard to tell which strings are\n//   used as URLs and which are used as file paths. In some cases, a string can\n//   be used as both, meaning it has to have forward slashes no matter what.\n\n// 2. Line endings in text files\n\n//   We have decided to convert all files read by the tool to Unix-style line\n//   endings for the same reasons as slashes above. In many parts of the tool,\n//   we assume that '\\n' is the line separator, and it can be hard to find all\n//   of the places and decide whether it is appropriate to use os.EOL. We do not\n//   convert anything on write. We will wait and see if anyone complains.\n\n// 3. Colons and other invalid characters in file paths\n\n//   This is not handled automatically by files.js. You need to be careful to\n//   escape any colons in package names, etc, before using a string as a file\n//   path.\n\n//   A helpful file to import for this purpose is colon-converter.js, which also\n//   knows how to convert various configuration file formats.\n\ntype wrapFsFuncOptions<TArgs extends any[], TResult> = {\n  cached?: boolean;\n  modifyReturnValue?: (result: TResult) => any;\n  dirty?: (...args: TArgs) => any;\n}\n\nfunction wrapFsFunc<TArgs extends any[], TResult>(\n  fnName: string,\n  fn: (...args: TArgs) => TResult,\n  pathArgIndices: number[],\n  options?: wrapFsFuncOptions<TArgs, TResult>,\n): typeof fn {\n  return Profile(\"files.\" + fnName, function (...args: TArgs) {\n    for (let j = pathArgIndices.length - 1; j >= 0; --j) {\n      const i = pathArgIndices[j];\n      args[i] = convertToOSPath(args[i]);\n    }\n\n    let cacheKey: string | null = null;\n    if (options && options.cached) {\n      const cache = withCacheSlot.getValue();\n      if (cache) {\n        const strings = [fnName];\n        const allStrings = args.every(arg => {\n          if (typeof arg === \"string\") {\n            strings.push(arg);\n            return true;\n          }\n          return false;\n        });\n        if (allStrings) {\n          cacheKey = JSON.stringify(strings);\n          if (hasOwnProperty.call(cache, cacheKey)) {\n            return cache[cacheKey];\n          }\n        }\n      }\n    }\n\n    const result = fn.apply(fs, args);\n\n    if (options && options.dirty) {\n      options.dirty(...args);\n    }\n\n    const finalResult = options && options.modifyReturnValue\n      ? options.modifyReturnValue(result)\n      : result;\n\n    if (cacheKey) {\n      withCacheSlot.getValue()![cacheKey] = finalResult;\n    }\n\n    return finalResult;\n  });\n}\n\nconst withCacheSlot = new Slot<Record<string, any>>();\nexport function withCache<R>(fn: () => R): R {\n  const cache = withCacheSlot.getValue();\n  return cache ? fn() : withCacheSlot.withValue(Object.create(null), fn);\n}\n\nexport const dependOnPath = dep<string>();\n\nfunction wrapDestructiveFsFunc<TArgs extends any[], TResult>(\n  fnName: string,\n  fn: (...args: TArgs) => TResult,\n  pathArgIndices: number[] = [0],\n  options?: wrapFsFuncOptions<TArgs, TResult>,\n): typeof fn {\n  return wrapFsFunc<TArgs, TResult>(fnName, fn, pathArgIndices, {\n    ...options,\n    dirty(...args: TArgs) {\n      pathArgIndices.forEach(i => dependOnPath.dirty(args[i]));\n    }\n  });\n}\n\nexport const readFile = wrapFsFunc(\"readFile\", fs.readFileSync, [0], {\n  modifyReturnValue: function (fileData: Buffer | string) {\n    if (typeof fileData === \"string\") {\n      return convertToStandardLineEndings(fileData);\n    }\n    return fileData;\n  }\n});\n\n// Copies a file, which is expected to exist. Parent directories of \"to\" do not\n// have to exist. Treats symbolic links transparently (copies the contents, not\n// the link itself, and it's an error if the link doesn't point to a file).\nconst wrappedCopyFile = wrapDestructiveFsFunc(\"copyFile\", fs.copyFileSync, [0, 1]);\nexport function copyFile(from: string, to: string, flags = 0) {\n  mkdir_p(pathDirname(pathResolve(to)), 0o755);\n  wrappedCopyFile(from, to, flags);\n  const stat = statOrNull(from);\n  if (stat && stat.isFile()) {\n    // Create the file as readable and writable by everyone, and executable by\n    // everyone if the original file is executably by owner. (This mode will be\n    // modified by umask.) We don't copy the mode *directly* because this function\n    // is used by 'meteor create' which is copying from the read-only tools tree\n    // into a writable app.\n\n    // @ts-ignore\n    chmod(to, (stat.mode & 0o100) ? 0o777 : 0o666);\n  }\n}\n\nconst wrappedRename = wrapDestructiveFsFunc(\"rename\", fs.renameSync, [0, 1]);\nexport const rename = isWindowsLikeFilesystem() ? function (from: string, to: string) {\n  // Retries are necessary only on Windows, because the rename call can\n  // fail with EBUSY, which means the file is in use.\n  const osTo = convertToOSPath(to);\n  const startTimeMs = Date.now();\n  const intervalMs = 50;\n  const timeLimitMs = 1000;\n\n  return new Promise<void>((resolve, reject) => {\n    function attempt() {\n      try {\n        // Despite previous failures, the top-level destination directory\n        // may have been successfully created, so we must remove it to\n        // avoid moving the source file *into* the destination directory.\n        rimraf.sync(osTo);\n        wrappedRename(from, to);\n        resolve();\n      } catch (err) {\n        if (err.code !== 'EPERM' && err.code !== 'EACCES') {\n          reject(err);\n        } else if (Date.now() - startTimeMs < timeLimitMs) {\n          setTimeout(attempt, intervalMs);\n        } else {\n          reject(err);\n        }\n      }\n    }\n    attempt();\n  }).catch(error => {\n    if (error.code === 'EPERM' ||\n        error.code === 'EACCESS') {\n      cp_r(from, to, { preserveSymlinks: true });\n      rm_recursive(from);\n    } else {\n      throw error;\n    }\n  }).await();\n} : wrappedRename;\n\n// Warning: doesn't convert slashes in the second 'cache' arg\nexport const realpath =\nwrapFsFunc<[string], string>(\"realpath\", fs.realpathSync, [0], {\n  cached: true,\n  modifyReturnValue: convertToStandardPath,\n});\n\nexport const readdir =\nwrapFsFunc<[string], string[]>(\"readdir\", fs.readdirSync, [0], {\n  cached: true,\n  modifyReturnValue(entries: string[]) {\n    return entries.map(entry => convertToStandardPath(entry));\n  },\n});\n\nexport const readdirWithTypes = wrapFsFunc<[string], Dirent[]>(\"readdirWithTypes\", (dir) => {\n    return fs.readdirSync(dir, {\n      withFileTypes: true\n    });\n  }, [0], {\n  cached: true\n});\n\nexport const appendFile = wrapDestructiveFsFunc(\"appendFile\", fs.appendFileSync);\nexport const chmod = wrapDestructiveFsFunc(\"chmod\", fs.chmodSync);\nexport const close = wrapFsFunc(\"close\", fs.closeSync, []);\nexport const createReadStream = wrapFsFunc(\"createReadStream\", fs.createReadStream, [0]);\nexport const createWriteStream = wrapFsFunc(\"createWriteStream\", fs.createWriteStream, [0]);\nexport const lstat = wrapFsFunc(\"lstat\", fs.lstatSync, [0], { cached: true });\nexport const mkdir = wrapDestructiveFsFunc(\"mkdir\", fs.mkdirSync);\nexport const open = wrapFsFunc(\"open\", fs.openSync, [0]);\nexport const read = wrapFsFunc(\"read\", fs.readSync, []);\nexport const readlink = wrapFsFunc<[string], string>(\"readlink\", fs.readlinkSync, [0]);\nexport const rmdir = wrapDestructiveFsFunc(\"rmdir\", fs.rmdirSync);\nexport const stat = wrapFsFunc(\"stat\", fs.statSync as (path: PathLike) => Stats, [0], { cached: true });\nexport const symlink = wrapFsFunc(\"symlink\", fs.symlinkSync, [0, 1]);\nexport const unlink = wrapDestructiveFsFunc(\"unlink\", fs.unlinkSync);\nexport const write = wrapFsFunc(\"write\", fs.writeSync, []);\nexport const writeFile = wrapDestructiveFsFunc(\"writeFile\", fs.writeFileSync);\n\ntype StatListener = (\n  current: Stats,\n  previous: Stats,\n) => void;\n\ntype StatWatcherOptions = {\n  persistent?: boolean;\n  interval?: number;\n};\n\ninterface StatWatcher extends EventEmitter {\n  stop: () => void;\n  start: (\n    filename: string,\n    options: StatWatcherOptions,\n    listener: StatListener,\n  ) => void;\n}\n\nexport const watchFile = wrapFsFunc(\"watchFile\", (\n  filename: string,\n  options: StatWatcherOptions,\n  listener: StatListener,\n) => {\n  return fs.watchFile(\n    filename,\n    options,\n    listener,\n  ) as any as StatWatcher;\n}, [0]);\n\nexport const unwatchFile = wrapFsFunc(\"unwatchFile\", (\n  filename: string,\n  listener?: StatListener,\n) => {\n  return fs.unwatchFile(filename, listener);\n}, [0]);\n"]}