{"version":3,"file":"tools/fs/watch.js.map","mappings":"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","names":["module","default","_objectSpread","_defineProperty","export","WatchSet","readFile","sha1","sha512","readDirectory","Watcher","isUpToDate","readAndWatchDirectory","readAndWatchFileWithHash","readAndWatchFile","files","safeWatcher","createHash","coalesce","Profile","optimisticHashOrNull","optimisticStatOrNull","_","require","WATCH_COALESCE_MS","process","env","METEOR_FILE_WATCH_COALESCE_MS","Object","create","Set","addFile","filePath","hash","potentiallyUnusedFiles","delete","alwaysFire","has","hasFile","isDefinitelyUsed","isPotentiallyUnused","addPotentiallyUnusedFile","alreadyUsed","add","addDirectory","absPath","include","exclude","names","contents","isEmpty","directories","push","slice","sort","merge","that","keys","forEach","name","dir","clone","ret","entry","toJSON","reToJSON","r","options","ignoreCase","multiline","global","$regex","source","$options","map","d","fromJSON","json","watchSet","Array","isArray","reFromJSON","j","RegExp","e","code","args","arg","update","digest","readAndStatDirectory","readdirWithTypes","contentsWithSlashes","stat","isSymbolicLink","pathJoin","isDirectory","filterDirectoryContents","filter","indexOf","some","re","test","constructor","async","onChange","justCheckOnce","includePotentiallyUnusedFiles","fire","startFileWatches","checkDirectories","fireIfFileChanged","stopped","oldHash","Error","newHash","fireIfDirectoryChanged","infos","info","newContents","isEqual","processBatches","watchFileOrDirectory","skipCheck","watches","watcher","lastStat","undefined","statOrNull","mustNotExist","onWatchEvent","makeWatchEventCallback","watch","updateStatForWatch","mustBeAFile","parentDir","pathDirname","isFile","dirFiles","readdir","err","file","fullPath","length","wsFiles","isString","array","handleItem","index","processBatch","stopTime","Date","now","Infinity","setImmediate","dirs","values","reduce","result","entries","stop","each","close","time","upToDate"],"sourceRoot":"","sources":["tools/fs/watch.ts"],"sourcesContent":["import { Stats, BigIntStats, FSWatcher, Dirent } from \"fs\";\nimport * as files from \"./files\";\nimport * as safeWatcher from \"./safe-watcher\";\nimport { createHash } from \"crypto\";\nimport { coalesce } from \"../utils/func-utils\";\nimport { Profile } from \"../tool-env/profile\";\nimport {\n  optimisticHashOrNull,\n  optimisticStatOrNull,\n} from \"./optimistic\";\n\nconst _ = require(\"underscore\");\n\nconst WATCH_COALESCE_MS =\n  +(process.env.METEOR_FILE_WATCH_COALESCE_MS || 100);\n\n// Watch for changes to a set of files, and the first time that any of\n// the files change, call a user-provided callback. (If you want a\n// second callback, you'll need to create a second Watcher.)\n//\n// You describe the structure you want to watch in a WatchSet; you then create a\n// Watcher to watch it. Watcher does not mutate WatchSet, so you can create\n// several Watchers from the same WatchSet. WatchSet can be easily converted to\n// and from JSON for serialization.\n//\n// You can set up two kinds of watches, file and directory watches.\n//\n// In a file watch, you provide an absolute path to a file and a SHA1 (encoded\n// as hex) of the contents of that file. If the file ever changes so that its\n// contents no longer match that SHA1, the callback triggers. You can also\n// provide `null` for the SHA1, which means the file should not exist.\n//\n// In a directory watch, you provide an absolute path to a directory,\n// two lists of regular expressions specifying the entries to\n// include and exclude, a list of specific names to include (which ignores\n// the exclude regexp list) and an array of which entries to expect.\n//\n// For directory watches, the regular expressions work as follows. You provide\n// two arrays of regular expressions, an include list and an exclude list. An\n// entry in the directory matches if it matches at least one regular expression\n// in the include list, and doesn't match any regular expressions in the exclude\n// list. The string that is matched against the regular expression ends with a\n// '/' if the entry is directory. There is NO IMPLICIT RECURSION here: a\n// directory watch ONLY watches the immediate children of the directory! If you\n// want a recursive watch, you need to do the recursive walk while building the\n// WatchSet and add a bunch of separate directory watches.  In addition, you\n// can provide a list of specific names to expect; these are not filtered\n// by the exclude list.  (For example, you might want to see all \"*.js\" files\n// but ignore files starting with dots (which are often temporary files), but\n// explicitly ask for \".jshintrc\".)\n//\n// There can be multiple directory watches on the same directory. There is no\n// relationship between the files found in directory watches and the files\n// watched by file watches; they are parallel mechanisms.\n//\n// Regular expressions are checked only against individual path components (the\n// actual name of the file or the subdirectory) plus the trailing '/' for\n// directories, not against the entire path.\n//\n// You can call stop() to stop watching and tear down the\n// watcher. Calling stop() guarantees that you will not receive a\n// callback (if you have not already). Calling stop() is unnecessary\n// if you've received a callback.\n//\n// To do a \"one-shot\" (to see if any files have been modified, compared to the\n// dependencies, at a particular point in time), use the isUpToDate function.\n//\n// XXX Symlinks are currently treated transparently: we treat them as the thing\n// they point to (ie, as a directory if they point to a directory, as\n// nonexistent if they point to something nonexist, etc). Not sure if this is\n// correct.\n\ntype DirectoryEntry = {\n  absPath: string;\n  include: RegExp[];\n  exclude: RegExp[];\n  names: string[];\n  contents: string[] | null;\n}\n\nexport class WatchSet {\n  // Set this to true if any Watcher built on this WatchSet must immediately\n  // fire (eg, if this WatchSet was given two different sha1 for the same file).\n  public alwaysFire = false;\n\n  // Map from the absolute path to a file, to a sha1 hash, or null if the file\n  // should not exist. A Watcher created from this set fires when the file\n  // changes from that sha, or is deleted (if non-null) or created (if null).\n  //\n  // Note that Isopack.getSourceFilesUnderSourceRoot() depends on this field\n  // existing (it's not just an internal implementation detail of watch.ts).\n  public readonly files: Record<string, string | null> = Object.create(null);\n\n  // This represents the assertion that 'absPath' is a directory and that\n  // 'contents' is its immediate contents, as filtered by the regular\n  // expressions.  Entries in 'contents' are file and subdirectory names;\n  // directory names end with '/'. 'contents' is sorted. An entry is in\n  // 'contents' if its value (including the slash, for directories) matches at\n  // least one regular expression in 'include' and no regular expressions in\n  // 'exclude'... or if it is in 'names'.\n  //\n  // There is no recursion here: files contained in subdirectories never appear.\n  //\n  // A directory may have multiple entries (presumably with different\n  // include/exclude filters).\n  public readonly directories: DirectoryEntry[] = [];\n\n  public addFile(filePath: string, hash: string | null) {\n    // Calling addFile directly instead of addPotentiallyUnusedFile implies\n    // that the file will be used, so we can mark it as such here. Note that\n    // addPotentiallyUnusedFile overrides this value based on the alreadyUsed\n    // variable after calling this.addFile.\n    this.potentiallyUnusedFiles.delete(filePath);\n\n    // No need to update if this is in always-fire mode already.\n    if (this.alwaysFire) {\n      return;\n    }\n\n    if (_.has(this.files, filePath)) {\n      // Redundant?\n      if (this.files[filePath] === hash) {\n        return;\n      }\n      // Nope, inconsistent.\n      this.alwaysFire = true;\n      return;\n    }\n\n    this.files[filePath] = hash;\n  }\n\n  public hasFile(filePath: string): boolean {\n    return _.has(this.files, filePath);\n  }\n\n  // Files added via addPotentiallyUnusedFile will be included in this Set\n  // until addFile is called at a later time, which removes them from the\n  // potentiallyUnusedFiles Set and prevents them from being considered as\n  // potentially unused in the future. Either way, this.files will have\n  // the same contents as if addFile was called instead, which is\n  // important for checks such as IsopackCache._checkUpToDate, which need\n  // to take everything (even potentially unused files) into account.\n  private potentiallyUnusedFiles = new Set<string>();\n\n  public isDefinitelyUsed(filePath: string): boolean {\n    return this.hasFile(filePath) && ! this.isPotentiallyUnused(filePath);\n  }\n\n  public isPotentiallyUnused(filePath: string): boolean {\n    return this.potentiallyUnusedFiles.has(filePath);\n  }\n\n  public addPotentiallyUnusedFile(filePath: string, hash: string | null) {\n    const alreadyUsed = this.isDefinitelyUsed(filePath);\n    this.addFile(filePath, hash);\n    if (! alreadyUsed) {\n      this.potentiallyUnusedFiles.add(filePath);\n    }\n  }\n\n  public addDirectory({\n    absPath,\n    include,\n    exclude,\n    names,\n    contents,\n  }: DirectoryEntry) {\n    if (this.alwaysFire) return;\n    if (_.isEmpty(include) && _.isEmpty(names)) {\n      return;\n    }\n    this.directories.push({\n      absPath,\n      include,\n      exclude,\n      names,\n      contents: contents && contents.slice(0).sort(),\n    });\n  }\n\n  // Merges another WatchSet into this one. This one will now fire if either\n  // WatchSet would have fired.\n  public merge(that: WatchSet) {\n    if (this.alwaysFire) return;\n    if (that.alwaysFire) {\n      this.alwaysFire = true;\n      return;\n    }\n\n    Object.keys(that.files).forEach(name => {\n      if (that.isPotentiallyUnused(name)) {\n        this.addPotentiallyUnusedFile(name, that.files[name]);\n      } else {\n        this.addFile(name, that.files[name]);\n      }\n    });\n\n    that.directories.forEach(dir => {\n      // XXX this doesn't deep-clone the directory, but I think these objects\n      // are never mutated #WatchSetShallowClone #TypeScriptOpportunity\n      this.directories.push(dir);\n    });\n  }\n\n  public clone() {\n    const ret = new WatchSet();\n\n    ret.alwaysFire = this.alwaysFire;\n\n    Object.keys(this.files).forEach(name => {\n      ret.files[name] = this.files[name];\n    });\n\n    this.potentiallyUnusedFiles.forEach(name => {\n      ret.potentiallyUnusedFiles.add(name);\n    });\n\n    // XXX doesn't bother to deep-clone the directory info\n    // #WatchSetShallowClone\n    this.directories.forEach(entry => {\n      ret.directories.push(entry);\n    });\n\n    return ret;\n  }\n\n  toJSON() {\n    if (this.alwaysFire) {\n      return { alwaysFire: true };\n    }\n\n    function reToJSON(r: RegExp) {\n      let options = '';\n      if (r.ignoreCase) {\n        options += 'i';\n      }\n      if (r.multiline) {\n        options += 'm';\n      }\n      if (r.global) {\n        options += 'g';\n      }\n      if (options) {\n        return {\n          $regex: r.source,\n          $options: options,\n        };\n      }\n      return r.source;\n    }\n\n    const potentiallyUnusedFiles: string[] = [];\n    this.potentiallyUnusedFiles.forEach(name => {\n      potentiallyUnusedFiles.push(name);\n    });\n\n    return {\n      files: this.files,\n      potentiallyUnusedFiles,\n      directories: this.directories.map(d => ({\n        absPath: d.absPath,\n        include: d.include.map(reToJSON),\n        exclude: d.exclude.map(reToJSON),\n        names: d.names,\n        contents: d.contents\n      })),\n    };\n  }\n\n  static fromJSON(json: any) {\n    const watchSet = new WatchSet();\n\n    if (! json) {\n      return watchSet;\n    }\n\n    if (json.alwaysFire) {\n      watchSet.alwaysFire = true;\n      return watchSet;\n    }\n\n    Object.keys(json.files).forEach(name => {\n      watchSet.files[name] = json.files[name];\n    });\n\n    if (Array.isArray(json.potentiallyUnusedFiles)) {\n      json.potentiallyUnusedFiles.forEach((name: string) => {\n        watchSet.potentiallyUnusedFiles.add(name);\n      });\n    }\n\n    function reFromJSON(j: any) {\n      if (j.$regex) {\n        return new RegExp(j.$regex, j.$options);\n      }\n      return new RegExp(j);\n    }\n\n    json.directories.forEach((d: any) => {\n      watchSet.directories.push({\n        absPath: d.absPath,\n        include: d.include.map(reFromJSON),\n        exclude: d.exclude.map(reFromJSON),\n        names: d.names,\n        contents: d.contents,\n      })\n    });\n\n    return watchSet;\n  }\n}\n\nexport function readFile(absPath: string) {\n  try {\n    return files.readFile(absPath);\n  } catch (e) {\n    // Rethrow most errors.\n    if (! e || (e.code !== 'ENOENT' && e.code !== 'EISDIR')) {\n      throw e;\n    }\n    // File does not exist (or is a directory).\n    return null;\n  }\n};\n\nexport const sha1 = Profile(\"sha1\", function (...args: (string | Buffer)[]) {\n  const hash = createHash('sha1');\n  args.forEach(arg => hash.update(arg));\n  return hash.digest('hex');\n});\n\nexport const sha512 = Profile(\"sha512\", function (...args: (string | Buffer)[]) {\n  const hash = createHash('sha512');\n  args.forEach(arg => hash.update(arg));\n  return hash.digest('base64');\n});\n\nfunction readAndStatDirectory(absPath: string) {\n  // Read the directory.\n  try {\n    var contents = files.readdirWithTypes(absPath);\n  } catch (e) {\n    // If the path is not a directory, return null; let other errors through.\n    if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) {\n      return null;\n    }\n    throw e;\n  }\n\n  // Add slashes to the end of directories.\n  const contentsWithSlashes: string[] = [];\n  contents.forEach(entry => {\n    let stat: Dirent | Stats | BigIntStats | null | undefined = entry;\n    let name = entry.name;\n\n    if (entry.isSymbolicLink()) {\n      // We do stat instead of lstat here, so that we treat symlinks to\n      // directories just like directories themselves.\n      stat = optimisticStatOrNull(files.pathJoin(absPath, entry.name));\n    }\n    if (! stat) {\n      // Disappeared after the readdir (or a dangling symlink)?\n      // Eh, pretend it was never there in the first place.\n      return;\n    }\n\n    if (stat.isDirectory()) {\n      name += '/';\n    }\n\n    contentsWithSlashes.push(name);\n  });\n\n  return contentsWithSlashes;\n}\n\nfunction filterDirectoryContents(contents: string[], {\n  include,\n  exclude,\n  names,\n}: {\n  include?: RegExp[],\n  exclude?: RegExp[],\n  names?: string[],\n}) {\n  // Filter based on regexps.\n  return contents.filter(entry => {\n    // Is it one of the names we explicitly requested?\n    if (names && names.indexOf(entry) !== -1) {\n      return true;\n    }\n    // Is it ruled out by an exclude rule?\n    if (exclude && exclude.some(re => re.test(entry))) {\n      return false;\n    }\n    // Is it ruled in by an include rule?\n    if (include && include.some(re => re.test(entry))) {\n      return true;\n    }\n    return false;\n  }).sort();\n}\n\nexport function readDirectory({ absPath, include, exclude, names }: {\n  absPath: string;\n  include?: RegExp[],\n  exclude?: RegExp[],\n  names?: string[],\n}) {\n  const contents = readAndStatDirectory(absPath);\n  return contents ? filterDirectoryContents(contents, {\n    include, exclude, names\n  }) : [];\n}\n\n// All fields are private.\nexport class Watcher {\n  private watchSet: WatchSet;\n  private onChange: () => any;\n  private stopped = false;\n  private justCheckOnce = false;\n  private async = false;\n  private includePotentiallyUnusedFiles = true;\n\n  private watches: Record<string, {\n    // Null until safeWatcher.watch succeeds in watching the file.\n    watcher: safeWatcher.SafeWatcher | null;\n    // Undefined until we stat the file for the first time, then null\n    // if the file is observed to be missing.\n    lastStat?: Stats | BigIntStats | null\n  }> = Object.create(null);\n\n  constructor(options: {\n    watchSet: WatchSet;\n    onChange: () => any;\n    async?: boolean;\n    justCheckOnce?: boolean;\n    includePotentiallyUnusedFiles?: boolean;\n  }) {\n    this.async = !! options.async;\n    this.watchSet = options.watchSet;\n    this.onChange = options.onChange;\n    this.justCheckOnce = !! options.justCheckOnce;\n    if (options.includePotentiallyUnusedFiles === false) {\n      this.includePotentiallyUnusedFiles = false;\n    }\n\n    // Were we given an inconsistent WatchSet? Fire now and be done with it.\n    if (this.watchSet.alwaysFire) {\n      this.fire();\n      return;\n    }\n\n    this.startFileWatches();\n    this.checkDirectories();\n  }\n\n  private fireIfFileChanged(absPath: string) {\n    if (this.stopped) {\n      return true;\n    }\n\n    if (\n      ! this.includePotentiallyUnusedFiles &&\n      this.watchSet.isPotentiallyUnused(absPath)\n    ) {\n      return false;\n    }\n\n    const oldHash = this.watchSet.files[absPath];\n    if (typeof oldHash === \"undefined\") {\n      throw new Error(\"Checking unknown file \" + absPath);\n    }\n\n    const newHash = optimisticHashOrNull(absPath);\n    if (newHash === null) {\n      // File does not exist (or is a directory).\n      // Is this what we expected?\n      if (oldHash === null) {\n        return false;\n      }\n      // Nope, not what we expected.\n      this.fire();\n      return true;\n    }\n\n    // File exists! Is that what we expected?\n    if (oldHash === null) {\n      this.fire();\n      return true;\n    }\n\n    // Unchanged?\n    if (newHash === oldHash) {\n      return false;\n    }\n\n    this.fire();\n    return true;\n  }\n\n  // infos must all be for the same directory\n  private fireIfDirectoryChanged(infos: DirectoryEntry[]) {\n    if (this.stopped) {\n      return true;\n    }\n\n    const contents = readAndStatDirectory(infos[0].absPath);\n\n    for (const info of infos) {\n      const newContents = filterDirectoryContents(contents || [], info);\n\n      // If the directory has changed (including being deleted or created).\n      if (! _.isEqual(info.contents, newContents)) {\n        this.fire();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private startFileWatches() {\n    const keys = Object.keys(this.watchSet.files);\n\n    // Set up a watch for each file\n    this.processBatches(keys, absPath => {\n      if (! this.justCheckOnce) {\n        this.watchFileOrDirectory(absPath, true);\n      }\n\n      // Check for the case where by the time we created the watch,\n      // the file had already changed from the sha we were provided.\n      this.fireIfFileChanged(absPath);\n    });\n  }\n\n  private watchFileOrDirectory(absPath: string, skipCheck = false) {\n    if (! _.has(this.watches, absPath)) {\n      this.watches[absPath] = {\n        watcher: null,\n        // Initially undefined (instead of null) to indicate we have never\n        // called files.stat on this file before.\n        lastStat: undefined\n      };\n    }\n\n    const entry = this.watches[absPath];\n    if (entry.watcher) {\n      // Already watching this path.\n      return;\n    }\n\n    if (files.statOrNull(absPath)) {\n      if (this.mustNotExist(absPath)) {\n        this.fire();\n        return;\n      }\n\n      const onWatchEvent = this.makeWatchEventCallback(absPath);\n      entry.watcher = safeWatcher.watch(absPath, onWatchEvent);\n\n      if (!skipCheck) {\n        // If we successfully created the watcher, invoke the callback\n        // immediately, so that we examine this file at least once.\n        onWatchEvent();\n      } else {\n        this.updateStatForWatch(absPath);\n      }\n\n    } else {\n      if (this.mustBeAFile(absPath)) {\n        this.fire();\n        return;\n      }\n\n      const parentDir = files.pathDirname(absPath);\n      if (parentDir === absPath) {\n        throw new Error(\"Unable to watch parent directory of \" + absPath);\n      }\n\n      this.watchFileOrDirectory(parentDir);\n    }\n  }\n\n  private makeWatchEventCallback(absPath: string) {\n    // Sometimes we receive a rapid succession of change events, perhaps\n    // because several files were modified at once (e.g. by git reset\n    // --hard), or a file was deleted and then recreated by an editor like\n    // Vim. Because detecting changes can be costly, and because we care\n    // most about the settled state of the file system, we use the\n    // funcUtils.coalesce helper to delay calls to the callback by\n    // METEOR_FILE_WATCH_COALESCE_MS or 100 milliseconds, canceling any\n    // additional calls if they happen within that window of time, so that\n    // a rapid succession of calls will tend to trigger only one inspection\n    // of the file system.\n    return coalesce<WatchSet>(WATCH_COALESCE_MS, () => {\n      if (this.stopped) {\n        return;\n      }\n\n      // This helper method will call this._fire() if the old and new stat\n      // objects have different types (missing, file, or directory), so we\n      // can assume they have the same type for the rest of this method.\n      const stat = this.updateStatForWatch(absPath);\n      if (this.stopped) {\n        return;\n      }\n\n      if (stat === null || stat.isFile()) {\n        if (_.has(this.watchSet.files, absPath)) {\n          this.fireIfFileChanged(absPath);\n          // XXX #3335 We probably should check again in a second, due to low\n          // filesystem modtime resolution.\n        }\n\n      } else if (stat.isDirectory()) {\n        try {\n          var dirFiles = files.readdir(absPath);\n        } catch (err) {\n          if (err.code === \"ENOENT\" ||\n              err.code === \"ENOTDIR\") {\n            // The directory was removed or changed type since we called\n            // this._updateStatForWatch, so we fire unconditionally.\n            this.fire();\n            return;\n          }\n          throw err;\n        }\n\n        dirFiles.forEach(file => {\n          const fullPath = files.pathJoin(absPath, file);\n\n          // Recursively watch new files, if we ever previously tried to\n          // watch them. Recall that when we attempt to watch a\n          // non-existent file, we actually watch the closest enclosing\n          // directory that exists, so once the file (and/or any\n          // intermediate directories) are created, we begin watching\n          // those directories in response to change events fired for\n          // directories we're already watching.\n          if (_.has(this.watches, fullPath)) {\n            this.watchFileOrDirectory(fullPath);\n          }\n        });\n\n        // If this.watchSet.directories contains any entries for the\n        // directory we are examining, call this._fireIfDirectoryChanged.\n        const infos = this.watchSet.directories.filter(info => info.absPath === absPath );\n        if (infos.length) {\n          this.fireIfDirectoryChanged(infos);\n        }\n        // XXX #3335 We probably should check again in a second, due to low\n        // filesystem modtime resolution.\n      }\n    });\n  }\n\n  private mustNotExist(absPath: string) {\n    const wsFiles = this.watchSet.files;\n    if (_.has(wsFiles, absPath)) {\n      return wsFiles[absPath] === null;\n    }\n    return false;\n  }\n\n  private mustBeAFile(absPath: string) {\n    const wsFiles = this.watchSet.files;\n    if (_.has(wsFiles, absPath)) {\n      return _.isString(wsFiles[absPath]);\n    }\n    return false;\n  }\n\n  private updateStatForWatch(absPath: string) {\n    const entry = this.watches[absPath];\n    const lastStat = entry.lastStat;\n    let stat = files.statOrNull(absPath);\n    const mustNotExist = this.mustNotExist(absPath);\n    const mustBeAFile = this.mustBeAFile(absPath);\n\n    if (stat && lastStat === undefined) {\n      // We have not checked for this file before, so our expectations are\n      // somewhat relaxed (namely, we don't care about lastStat), but\n      // this._fire() might still need to be called if this.watchSet.files\n      // has conflicting expectations.\n      if (stat.isFile()) {\n        if (mustNotExist) {\n          this.fire();\n        }\n      } else if (stat.isDirectory()) {\n        if (mustNotExist || mustBeAFile) {\n          this.fire();\n        }\n      } else {\n        // Neither a file nor a directory, so treat as non-existent.\n        stat = null;\n        if (mustBeAFile) {\n          this.fire();\n        }\n      }\n\n      // We have not checked for this file before, so just record the new\n      // stat object.\n      entry.lastStat = stat;\n\n    } else if (stat && stat.isFile()) {\n      entry.lastStat = stat;\n      if (! lastStat || ! lastStat.isFile()) {\n        this.fire();\n      }\n\n    } else if (stat && stat.isDirectory()) {\n      entry.lastStat = stat;\n      if (! lastStat || ! lastStat.isDirectory()) {\n        this.fire();\n      }\n\n    } else {\n      entry.lastStat = stat = null;\n      if (lastStat) {\n        this.fire();\n      }\n    }\n\n    return stat;\n  }\n\n  // Iterates over the array, calling handleItem for each item\n  // When this._async is true, it pauses ocassionally to avoid blocking for too long\n  // Stops iterating after watcher is stopped\n  private processBatches<T>(\n    array: T[],\n    handleItem: (item: T) => any,\n  ) {\n    let index = 0;\n\n    const processBatch = () => {\n      const stopTime = this.async ? Date.now() + 50 : Infinity;\n      while (Date.now() < stopTime && index < array.length) {\n        if (this.stopped) {\n          return;\n        }\n\n        handleItem(array[index]);\n\n        index += 1;\n      }\n\n      if (index < array.length) {\n        if (this.async) {\n          setImmediate(processBatch);\n        } else {\n          processBatch();\n        }\n      }\n    }\n\n    processBatch();\n  }\n\n  private checkDirectories() {\n    const dirs = Object.values(this.watchSet.directories.reduce((result, dir) => {\n      const dirs = result[dir.absPath];\n      if (dirs) {\n        dirs.push(dir);\n      } else {\n        result[dir.absPath] = [dir];\n      }\n      return result;\n    }, {} as Record<string, DirectoryEntry[]>));\n\n    if (this.stopped) {\n      return;\n    }\n\n    this.processBatches(dirs, entries => {\n      if (! this.justCheckOnce) {\n        this.watchFileOrDirectory(entries[0].absPath, true);\n      }\n\n      // Check for the case where by the time we created the watch, the\n      // directory has already changed.\n      this.fireIfDirectoryChanged(entries);\n    });\n  }\n\n  private fire() {\n    if (this.stopped) return;\n    this.stop();\n    this.onChange();\n  }\n\n  stop() {\n    this.stopped = true;\n    // Clean up file watches\n    _.each(this.watches, function (entry: { watcher: FSWatcher | null }) {\n      if (entry.watcher) {\n        entry.watcher.close();\n        entry.watcher = null;\n      }\n    });\n    this.watches = Object.create(null);\n  }\n}\n\n// Given a WatchSet, returns true if it currently describes the state of the\n// disk.\nexport function isUpToDate(\n  watchSet: WatchSet,\n  includePotentiallyUnusedFiles = true\n) {\n  return Profile.time('watch.isUpToDate', () => {\n    let upToDate = true;\n    const watcher = new Watcher({\n      watchSet: watchSet,\n      onChange() {\n        upToDate = false;\n      },\n      // internal flag which prevents us from starting watches and timers that\n      // we're about to cancel anyway\n      justCheckOnce: true,\n      includePotentiallyUnusedFiles,\n    });\n    watcher.stop();\n    return upToDate;\n  });\n}\n\n// Options should have absPath/include/exclude/names.\nexport function readAndWatchDirectory(\n  watchSet: WatchSet,\n  options: DirectoryEntry,\n) {\n  const contents = readDirectory(options);\n  watchSet.addDirectory({\n    contents,\n    ...options,\n  });\n  return contents;\n}\n\n// Calculating the sha hash can be expensive for large files.  By\n// returning the calculated hash along with the file contents, the\n// hash doesn't need to be calculated again for static files.\n//\n// We only calculate the hash if needed here, so callers must not\n// *rely* on the hash being returned; merely that if the hash is\n// present, it is the correct hash of the contents.\nexport function readAndWatchFileWithHash(watchSet: WatchSet, absPath: string) {\n  const result: {\n    contents: string | Buffer | null;\n    hash: string | null;\n  } = {\n    contents: null,\n    hash: null,\n  };\n\n  try {\n    result.contents = files.readFile(absPath);\n  } catch (e) {\n    if (e && e.code === \"EISDIR\") {\n      // Avoid adding directories to the watchSet as files.\n      return result;\n    }\n\n    if (e && e.code === \"ENOENT\") {\n      // Continue, leaving result.{contents,hash} both null.\n    } else {\n      // Throw all other errors.\n      throw e;\n    }\n  }\n\n  if (result.contents !== null) {\n    result.hash = sha1(result.contents);\n  }\n\n  // Allow null watchSet, if we want to use readFile-style error handling in a\n  // context where we might not always have a WatchSet (eg, reading\n  // settings.json where we watch for \"meteor run\" but not for \"meteor deploy\").\n  if (watchSet) {\n    watchSet.addFile(absPath, result.hash);\n  }\n\n  return result;\n}\n\nexport function readAndWatchFile(watchSet: WatchSet, absPath: string) {\n  return readAndWatchFileWithHash(watchSet, absPath).contents;\n}\n"]}