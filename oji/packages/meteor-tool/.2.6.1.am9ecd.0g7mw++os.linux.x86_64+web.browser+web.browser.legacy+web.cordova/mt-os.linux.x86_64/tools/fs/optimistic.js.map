{"version":3,"file":"tools/fs/optimistic.js.map","mappings":"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","names":["module","export","dirtyNodeModulesDirectory","optimisticStatOrNull","optimisticLStat","optimisticLStatOrNull","optimisticReadFile","optimisticReaddir","optimisticHashOrNull","optimisticReadJsonOrNull","optimisticReadMeteorIgnore","optimisticLookupPackageJsonArray","default","assert","wrap","dep","ignore","Profile","watch","sha1","pathSep","pathBasename","pathDirname","pathIsAbsolute","pathJoin","statOrNull","lstat","readFile","readdir","dependOnPath","findAppDir","ENABLED","process","env","METEOR_DISABLE_OPTIMISTIC_CACHING","makeOptimistic","name","fn","wrapper","maybeDependOnPath","arguments","apply","makeCacheKey","args","path","every","arg","join","subscribe","shouldWatch","ok","watcher","dirty","close","optimisticFindAppDir","parts","split","nmi","indexOf","dotMeteorIndex","lastIndexOf","length","nmi2","parentDirParts","slice","parentDir","appDir","startsWith","packageDirParts","push","packageDir","optimisticIsSymbolicLink","maybeDependOnNodeModules","index","dependOnNodeModules","strictEqual","pop","dependOnDirectory","dir","dependOnParentDirectory","nodeModulesDir","endsWith","makeCheapPathFunction","pathFunction","max","Math","pow","result","e","code","options","riskyJsonWhitespacePattern","contents","JSON","parse","SyntaxError","allowSyntaxError","stringContents","toString","cleanContents","replace","meteorIgnorePath","meteorIgnoreStat","isFile","add","absRootDir","relDir","absPkgJsonPath","pkgJson","relParentDir","parentArray","concat","isSymbolicLink"],"sourceRoot":"","sources":["tools/fs/optimistic.ts"],"sourcesContent":["import assert from \"assert\";\nimport { wrap, OptimisticWrapperFunction, dep } from \"optimism\";\nimport ignore from \"ignore\";\nimport { Profile } from \"../tool-env/profile\";\nimport { watch, SafeWatcher } from \"./safe-watcher\";\nimport { sha1 } from \"./watch\";\nimport {\n  pathSep,\n  pathBasename,\n  pathDirname,\n  pathIsAbsolute,\n  pathJoin,\n  statOrNull,\n  lstat,\n  readFile,\n  readdir,\n  dependOnPath,\n  findAppDir,\n} from \"./files\";\n\n// When in doubt, the optimistic caching system can be completely disabled\n// by setting this environment variable.\nconst ENABLED = ! process.env.METEOR_DISABLE_OPTIMISTIC_CACHING;\n\nfunction makeOptimistic<\n  TArgs extends any[],\n  TResult,\n>(\n  name: string,\n  fn: (...args: TArgs) => TResult,\n): OptimisticWrapperFunction<TArgs, TResult> {\n  fn = Profile(\"optimistic \" + name, fn);\n\n  const wrapper = wrap(ENABLED ? function (this: any) {\n    maybeDependOnPath(arguments[0]);\n    return fn.apply(this, arguments as any);\n  } as typeof fn : fn, {\n    makeCacheKey(...args: TArgs) {\n      if (! ENABLED) {\n        // Cache nothing when the optimistic caching system is disabled.\n        return;\n      }\n\n      const path = args[0];\n      if (! pathIsAbsolute(path)) {\n        return;\n      }\n\n      if (! args.every(arg => typeof arg === \"string\")) {\n        // If any of the arguments is not a string, then we won't cache the\n        // result of the corresponding file.* method invocation.\n        return;\n      }\n\n      return args.join(\"\\0\");\n    },\n\n    subscribe(...args: TArgs) {\n      const path = args[0];\n\n      if (! shouldWatch(path)) {\n        return;\n      }\n\n      assert.ok(pathIsAbsolute(path));\n\n      let watcher: SafeWatcher | null = watch(path, () => {\n        wrapper.dirty(...args);\n      });\n\n      return () => {\n        if (watcher) {\n          watcher.close();\n          watcher = null;\n        }\n      };\n    }\n  });\n\n  return wrapper;\n}\n\n// The Meteor application directory should never change during the lifetime\n// of the build process, so it should be safe to cache findAppDir without\n// subscribing to file changes.\nconst optimisticFindAppDir = wrap(findAppDir);\n\nconst shouldWatch = wrap(Profile(\"shouldWatch\", (path: string) => {\n  const parts = path.split(pathSep);\n  const nmi = parts.indexOf(\"node_modules\");\n\n  if (nmi < 0) {\n    // Watch everything not in a node_modules directory.\n    return true;\n  }\n\n  const dotMeteorIndex = parts.lastIndexOf(\".meteor\", nmi);\n  if (dotMeteorIndex >= 0) {\n    // Watch nothing inside of .meteor, at least for the purposes of the\n    // optimistic caching system. Meteor watches files inside .meteor/local\n    // via the WatchSet abstraction, unrelatedly.\n    return false;\n  }\n\n  if (nmi < parts.length - 1) {\n    const nmi2 = parts.indexOf(\"node_modules\", nmi + 1);\n    if (nmi2 > nmi) {\n      // If this path is nested inside more than one node_modules\n      // directory, then it isn't part of a linked npm package, so we\n      // should not watch it.\n      return false;\n    }\n\n    const parentDirParts = parts.slice(0, nmi);\n    const parentDir = parentDirParts.join(pathSep);\n    const appDir = optimisticFindAppDir(parentDir);\n    if (\n      appDir &&\n      parentDir.startsWith(appDir) &&\n      appDir.split(pathSep).length < parentDirParts.length\n    ) {\n      // If the given path is contained by the Meteor application directory,\n      // but the node_modules directory we're considering is not directly\n      // contained by the root application directory, watch the file. See\n      // discussion in issue https://github.com/meteor/meteor/issues/10664\n      return true;\n    }\n\n    const packageDirParts = parts.slice(0, nmi + 2);\n\n    if (parts[nmi + 1].startsWith(\"@\")) {\n      // For linked @scoped npm packages, the symlink is nested inside the\n      // @scoped directory (which is a child of node_modules).\n      packageDirParts.push(parts[nmi + 2]);\n    }\n\n    const packageDir = packageDirParts.join(pathSep);\n    if (optimisticIsSymbolicLink(packageDir)) {\n      // If this path is in a linked npm package, then it might be under\n      // active development, so we should watch it.\n      return true;\n    }\n  }\n\n  // Starting a watcher for every single file contained within a\n  // node_modules directory would be prohibitively expensive, so\n  // instead we rely on dependOnNodeModules to tell us when files in\n  // node_modules directories might have changed.\n  return false;\n}));\n\nfunction maybeDependOnPath(path: string) {\n  if (typeof path === \"string\") {\n    dependOnPath(path);\n    maybeDependOnNodeModules(path);\n  }\n}\n\nfunction maybeDependOnNodeModules(path: string) {\n  if (typeof path !== \"string\") {\n    return;\n  }\n\n  const parts = path.split(pathSep);\n\n  while (true) {\n    const index = parts.lastIndexOf(\"node_modules\");\n    if (index < 0) {\n      return;\n    }\n\n    parts.length = index + 1;\n    dependOnNodeModules(parts.join(pathSep));\n    assert.strictEqual(parts.pop(), \"node_modules\");\n  }\n}\n\nconst dependOnDirectory = dep({\n  subscribe(dir: string) {\n    let watcher: SafeWatcher | null = watch(\n      dir,\n      () => dependOnDirectory.dirty(dir),\n    );\n\n    return function () {\n      if (watcher) {\n        watcher.close();\n        watcher = null;\n      }\n    };\n  },\n});\n\n// Called when an optimistic function detects the given file does not\n// exist, but needs to return null or false rather than throwing an\n// exception. When/if the file is eventually created, we might only get a\n// file change notification for the parent directory, so it's important to\n// depend on the parent directory using this function, so that we don't\n// cache the unsuccessful result forever.\nfunction dependOnParentDirectory(path: string) {\n  const parentDir = pathDirname(path);\n  if (parentDir !== path) {\n    dependOnDirectory(parentDir);\n  }\n}\n\n// Called by any optimistic function that receives a */node_modules/* path\n// as its first argument, so that we can later bulk-invalidate the results\n// of those calls if the contents of the node_modules directory change.\n// Note that this strategy will not detect changes within subdirectories\n// of this node_modules directory, but that's ok because the use case we\n// care about is adding or removing npm packages.\nfunction dependOnNodeModules(nodeModulesDir: string) {\n  assert(pathIsAbsolute(nodeModulesDir), nodeModulesDir);\n  assert(nodeModulesDir.endsWith(pathSep + \"node_modules\"));\n  dependOnDirectory(nodeModulesDir);\n}\n\n// Invalidate all optimistic results derived from paths involving the\n// given node_modules directory.\nexport function dirtyNodeModulesDirectory(nodeModulesDir: string) {\n  dependOnDirectory.dirty(nodeModulesDir);\n}\n\nfunction makeCheapPathFunction<TResult>(\n  pathFunction: (path: string) => TResult,\n): typeof pathFunction {\n  if (! ENABLED) {\n    return pathFunction;\n  }\n  const wrapper = wrap(pathFunction, {\n    // The maximum LRU cache size is Math.pow(2, 16) by default, but it's\n    // important to prevent eviction churn for very-frequently-called\n    // functions like optimisticStatOrNull. While it's tempting to set\n    // this limit to Infinity, increasing it by 16x comes close enough.\n    max: Math.pow(2, 20),\n    subscribe(path) {\n      let watcher: SafeWatcher | null = watch(\n        path,\n        () => wrapper.dirty(path),\n      );\n      return function () {\n        if (watcher) {\n          watcher.close();\n          watcher = null;\n        }\n      };\n    }\n  });\n  return wrapper;\n}\n\nexport const optimisticStatOrNull = makeCheapPathFunction(\n  (path: string) => {\n    const result = statOrNull(path);\n    if (result === null) {\n      dependOnParentDirectory(path);\n    }\n    return result;\n  },\n);\n\nexport const optimisticLStat = makeOptimistic(\"lstat\", lstat);\nexport const optimisticLStatOrNull = makeCheapPathFunction(\n  (path: string) => {\n    try {\n      return optimisticLStat(path);\n    } catch (e) {\n      if (e.code !== \"ENOENT\") throw e;\n      dependOnParentDirectory(path);\n      return null;\n    }\n  },\n);\n\nexport const optimisticReadFile = makeOptimistic(\"readFile\", readFile);\nexport const optimisticReaddir = makeOptimistic(\"readdir\", readdir);\nexport const optimisticHashOrNull = makeOptimistic(\"hashOrNull\", (\n  path: string,\n  options?: Parameters<typeof optimisticReadFile>[1],\n) => {\n  try {\n    return sha1(optimisticReadFile(path, options)) as string;\n\n  } catch (e) {\n    if (e.code !== \"EISDIR\" &&\n        e.code !== \"ENOENT\") {\n      throw e;\n    }\n  }\n\n  dependOnParentDirectory(path);\n\n  return null;\n});\n\nconst riskyJsonWhitespacePattern =\n  // Turns out a lot of weird characters technically count as /\\s/ characters.\n  // This is all of them except for \" \", \"\\n\", and \"\\r\", which are safe:\n  /[\\t\\b\\f\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/g;\n\nexport const optimisticReadJsonOrNull =\nmakeOptimistic(\"readJsonOrNull\", (\n  path: string,\n  options?: Parameters<typeof optimisticReadFile>[1] & {\n    allowSyntaxError?: boolean;\n  },\n): Record<string, any> | null => {\n  let contents: string | Buffer;\n  try {\n    contents = optimisticReadFile(path, options);\n  } catch (e) {\n    if (e.code === \"ENOENT\") {\n      dependOnParentDirectory(path);\n      return null;\n    }\n    throw e;\n  }\n\n  try {\n    return JSON.parse(contents);\n  } catch (e) {\n    if (e instanceof SyntaxError &&\n        options && options.allowSyntaxError) {\n      return null;\n    }\n\n    const stringContents: string = contents.toString(\"utf8\");\n    // Replace any risky whitespace characters with spaces, to address issue\n    // https://github.com/meteor/meteor/issues/10688\n    const cleanContents = stringContents.replace(riskyJsonWhitespacePattern, \" \");\n    if (cleanContents !== stringContents) {\n      // Try one last time to parse cleanContents before throwing.\n      return JSON.parse(cleanContents);\n    }\n\n    throw e;\n  }\n});\n\nexport const optimisticReadMeteorIgnore = wrap((dir: string) => {\n  const meteorIgnorePath = pathJoin(dir, \".meteorignore\");\n  const meteorIgnoreStat = optimisticStatOrNull(meteorIgnorePath);\n\n  if (meteorIgnoreStat &&\n      meteorIgnoreStat.isFile()) {\n    return ignore().add(\n      optimisticReadFile(meteorIgnorePath).toString(\"utf8\")\n    );\n  }\n\n  return null;\n});\n\ntype LookupPkgJsonType = OptimisticWrapperFunction<\n  [string, string],\n  ReturnType<typeof optimisticReadJsonOrNull>[]\n>;\n\n// Returns an array of package.json objects encountered in any directory\n// between relDir and absRootDir. If a package.json with a \"name\" property\n// is found, it will always be the first object in the array.\nexport const optimisticLookupPackageJsonArray: LookupPkgJsonType =\nwrap((absRootDir: string, relDir: string) => {\n  const absPkgJsonPath = pathJoin(absRootDir, relDir, \"package.json\");\n  const pkgJson = optimisticReadJsonOrNull(absPkgJsonPath);\n\n  // Named package.json files always terminate the search. This\n  // restriction was first introduced to fix #10547, before this function\n  // was updated to return an array instead of a single object, but\n  // returning here is still an important base case.\n  if (pkgJson && typeof pkgJson.name === \"string\") {\n    return [pkgJson];\n  }\n\n  const relParentDir = pathDirname(relDir);\n  if (relParentDir === relDir) {\n    return [];\n  }\n\n  // Stop searching if an ancestor node_modules directory is encountered.\n  if (pathBasename(relParentDir) === \"node_modules\") {\n    return [];\n  }\n\n  const parentArray =\n    optimisticLookupPackageJsonArray(absRootDir, relParentDir);\n\n  if (pkgJson) {\n    // If an intermediate package.json file was found, add its object to\n    // the array. Since these arrays are cached, we don't want to modify\n    // them using parentArray.push(pkgJson), hence concat.\n    return parentArray.concat(pkgJson);\n  }\n\n  return parentArray;\n});\n\nconst optimisticIsSymbolicLink = wrap((path: string) => {\n  try {\n    return lstat(path)?.isSymbolicLink();\n  } catch (e) {\n    if (e.code !== \"ENOENT\") throw e;\n    dependOnParentDirectory(path);\n    return false;\n  }\n}, {\n  subscribe(path) {\n    let watcher: SafeWatcher | null = watch(path, () => {\n      optimisticIsSymbolicLink.dirty(path);\n    });\n\n    return function () {\n      if (watcher) {\n        watcher.close();\n        watcher = null;\n      }\n    };\n  }\n});\n"]}