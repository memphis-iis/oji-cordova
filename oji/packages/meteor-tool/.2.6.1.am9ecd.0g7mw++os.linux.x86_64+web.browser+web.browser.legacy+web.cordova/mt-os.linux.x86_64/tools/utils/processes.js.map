{"version":3,"file":"tools/utils/processes.js.map","mappings":"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","names":["module","default","_objectSpread","export","execFileSync","execFileAsync","child_process","convertToOSPath","command","args","options","meteorPromise","Promise","await","waitForClose","Array","isArray","cwd","exitEvent","resolve","reject","child","spawnArgs","env","stdio","process","platform","spawn","forEach","arg","exec","capturedStdout","stdout","destination","pipe","setEncoding","on","data","capturedStderr","stderr","errorCallback","error","removeListener","exitCallback","trim","Object","assign","pid","code","message","signal","errorMessage","join","Error","status"],"sourceRoot":"","sources":["tools/utils/processes.ts"],"sourcesContent":["import child_process from 'child_process';\nimport { Writable } from 'stream';\nimport { convertToOSPath } from '../static-assets/server/mini-files';\n\n// The execFileSync function is meant to resemble the similarly-named Node 0.12\n// synchronous process creation API, but instead of being fully blocking it\n// uses a promise-based implementation. You can also use\n// execFileAsync directly, which returns a promise.\n// Some functionality is currently missing but could be added when the need\n// arises (e.g. support for timeout, maxBuffer, and encoding options).\n// Eventually, these versions should replace the ones in tools/utils/utils.js\n// and tools/tool-testing/selftest.js.\n\ntype ExecFileOptions = {\n  /**\n   * Current working directory of the child process\n   */\n  cwd?: string,\n\n  /**\n   * Environment key-value pairs\n   */\n  env?: NodeJS.ProcessEnv,\n\n  /**\n   * Child's stdio configuration.\n   * (Default: 'pipe') Specifying anything but 'pipe' will disallow capture.\n   */\n  stdio?: 'pipe' | Array<null | undefined | 'pipe'>,\n\n  /**\n   * If specified, instead of capturing the output, the child process stdout\n   * will be piped to the destination stream.\n   */\n  destination?: Writable,\n\n  /**\n   * Whether to wait for the child process streams to close or to resolve\n   * the promise when the child process exits.\n   */\n  waitForClose?: boolean,\n}\n\n /**\n  * @summary Executes a command synchronously, returning either the captured\n  * stdout output or throwing an error containing the stderr output as part of\n  * the message. In addition, the error will contain fields pid, stderr, stdout,\n  * status and signal.\n  * @param command The command to run\n  * @param args List of string arguments\n  * @param options \n  * @returns The stdout from the command\n  */\nexport function execFileSync(\n  command: string,\n  args?: ReadonlyArray<string> | ExecFileOptions,\n  options?: ExecFileOptions\n) {\n  const meteorPromise: any = Promise; // TypeScript doesn't recognize \"Promise.await\"\n  return meteorPromise.await(execFileAsync(command, args, options));\n}\n\n /**\n  * @summary Executes a command asynchronously, returning a promise that will\n  * either be resolved to the captured stdout output or be rejected with an\n  * error containing the stderr output as part of the message. In addition,\n  * the error will contain fields pid, stderr, stdout, status and signal.\n  * @param command The command to run\n  * @param args List of string arguments\n  * @param options \n  */\nexport function execFileAsync(\n  command: string,\n  args?: ReadonlyArray<string> | ExecFileOptions,\n  options: ExecFileOptions = { waitForClose: true }\n) {\n  // args is optional, so if it's not an array we interpret it as options\n  if (!Array.isArray(args)) {\n    options = {\n      ...options,\n      ...args,\n    }\n  }\n\n  if (options.cwd) {\n    options.cwd = convertToOSPath(options.cwd);\n  }\n\n  // The child process close event is emitted when the stdio streams\n  // have all terminated. If those streams are shared with other\n  // processes, that means we won't receive a 'close' until all processes\n  // have exited, so we may want to respond to 'exit' instead.\n  // (The downside of responding to 'exit' is that the streams may not be\n  // fully flushed, so we could miss captured output. Only use this\n  // option when needed.)\n  const exitEvent = options.waitForClose ? 'close' : 'exit';\n\n  return new Promise((resolve, reject) => {\n    let child: ReturnType<typeof child_process.exec>; \n    const spawnArgs: ReadonlyArray<string> = Array.isArray(args) ? args : [];\n    const { cwd, env, stdio } = options;\n\n    if (process.platform !== 'win32') {\n      child = child_process.spawn(command, spawnArgs, { cwd, env, stdio });\n    } else {\n      // https://github.com/nodejs/node-v0.x-archive/issues/2318\n      spawnArgs.forEach(arg => {\n        command += ' ' + arg;\n      });\n      child = child_process.exec(command, { cwd, env });\n    }\n\n    let capturedStdout = '';\n    if (child.stdout) {\n      if (options.destination) {\n        child.stdout.pipe(options.destination);\n      } else {\n        child.stdout.setEncoding('utf8');\n        child.stdout.on('data', (data: string) => {\n          capturedStdout += data;\n        });\n      }\n    }\n\n    let capturedStderr = '';\n    if (child.stderr) {\n      child.stderr.setEncoding('utf8');\n      child.stderr.on('data', (data: string) => {\n        capturedStderr += data;\n      });\n    }\n\n    const errorCallback = (error: NodeJS.ErrnoException) => {\n      // Make sure we only receive one type of callback\n      child.removeListener(exitEvent, exitCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      Object.assign(error, {\n        pid: child.pid,\n        stdout: capturedStdout,\n        stderr: capturedStderr,\n      });\n\n      // Set a more informative error message on ENOENT, that includes the\n      // command we attempted to execute\n      if (error.code === 'ENOENT') {\n        error.message = `Could not find command '${command}'`;\n      }\n\n      reject(error);\n    };\n    child.on('error', errorCallback);\n\n    const exitCallback = (code: number, signal: string) => {\n      // Make sure we only receive one type of callback\n      child.removeListener('error', errorCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      if (code === 0) {\n        resolve(capturedStdout);\n      } else {\n        let errorMessage = `Command failed: ${command}`;\n        if (spawnArgs) {\n          errorMessage += ` ${spawnArgs.join(' ')}`;\n        }\n        errorMessage += `\\n${capturedStderr}`;\n\n        const error = new Error(errorMessage);\n\n        Object.assign(error, {\n          pid: child.pid,\n          stdout: capturedStdout,\n          stderr: capturedStderr,\n          status: code,\n          signal: signal\n        })\n\n        reject(error);\n      }\n    };\n    child.on(exitEvent, exitCallback);\n  });\n}\n"]}