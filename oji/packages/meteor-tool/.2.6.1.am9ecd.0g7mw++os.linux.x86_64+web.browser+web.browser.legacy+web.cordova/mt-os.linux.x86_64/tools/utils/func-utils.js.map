{"version":3,"file":"tools/utils/func-utils.js.map","mappings":"AAGAA;AAAAC;AAAA;;AAGM,SAAUA,QAAV,CACJC,OADI,EAEJC,QAFI,EAGJC,OAHI,EAGc;AAElB,MAAIC,OAAO,GAAG,KAAd;AACA,MAAIC,UAAU,GAAG,CAAjB;AAEA,QAAMC,aAAa,GAAGL,OAAO,IAAI,GAAjC;;AAEA,WAASM,iBAAT,GAA0B;AACxB,UAAMC,IAAI,GAAGL,OAAO,IAAI,IAAxB;;AAEA,QAAIE,UAAJ,EAAgB;AACd;AACA;AACA,QAAEA,UAAF;AACA;AACD;;AAED,QAAID,OAAJ,EAAa;AACX;AACA;AACD;;AAED,QAAIK,OAAJ,CACEC,OAAO,IAAIC,UAAU,CAACD,OAAD,EAAUJ,aAAV,CADvB,EAEEM,IAFF,CAEO,SAASC,YAAT,GAAqB;AAC1B;AACA;AACA;AACA;AACA;AACAT,aAAO,GAAG,KAAV;AACAC,gBAAU,GAAG,CAAb;;AAEA,UAAI;AACFH,gBAAQ,CAACY,IAAT,CAAcN,IAAd;AACD,OAFD,SAEU;AACR,YAAIH,UAAU,GAAG,CAAjB,EAAoB;AAClBI,iBAAO,CAACC,OAAR,GAAkBE,IAAlB,CAAuBC,YAAvB;AACAT,iBAAO,GAAG,IAAV;AACD;;AACDC,kBAAU,GAAG,CAAb;AACD;AACF,KApBD;AAqBD;;AAED,SAAOU,IAAI,CAACR,iBAAD,EAAoBL,QAApB,CAAX;AACD;;AAAA;;AAED,SAASa,IAAT,CAGEC,OAHF,EAGqBC,OAHrB,EAGsC;AACpC;AACA;AACAD,SAAO,CAACE,SAAR,GAAoBD,OAAO,CAACC,SAA5B,CAHoC,CAKpC;;AACA,QAAMC,IAAI,GAAGF,OAAO,CAACG,WAAR,IAAuBH,OAAO,CAACE,IAA5C;;AACA,MAAIA,IAAJ,EAAU;AACRH,WAAO,CAACI,WAAR,GAAsBD,IAAtB;AACD;;AAED,SAAOH,OAAP;AACD","names":["module","coalesce","delayMs","callback","context","pending","inProgress","actualDelayMs","coalescingWrapper","self","Promise","resolve","setTimeout","then","thenCallback","call","wrap","wrapper","wrapped","prototype","name","displayName"],"sourceRoot":"","sources":["tools/utils/func-utils.ts"],"sourcesContent":["type EmptyFunction = () => void;\ntype AnyFunction = (...args: any[]) => any;\n\n// Return a function that coalesceses calls to fn that occur within delay\n// milliseconds of each other, and prevents overlapping invocations of fn\n// by postponing the next invocation until after fn's fiber finishes.\nexport function coalesce<TContext>(\n  delayMs: number,\n  callback: EmptyFunction,\n  context?: TContext,\n): EmptyFunction {\n  let pending = false;\n  let inProgress = 0;\n\n  const actualDelayMs = delayMs || 100;\n\n  function coalescingWrapper(this: TContext) {\n    const self = context || this;\n\n    if (inProgress) {\n      // Indicate that coalescingWrapper should be called again after the\n      // callback is no longer in progress.\n      ++inProgress;\n      return;\n    }\n\n    if (pending) {\n      // Defer to the already-pending timer.\n      return;\n    }\n\n    new Promise(\n      resolve => setTimeout(resolve, actualDelayMs)\n    ).then(function thenCallback() {\n      // Now that the timeout has fired, set inProgress to 1 so that\n      // (until the callback is complete and we set inProgress to 0 again)\n      // any calls to coalescingWrapper will increment inProgress to\n      // indicate that at least one other caller wants fiberCallback to be\n      // called again when the original callback is complete.\n      pending = false;\n      inProgress = 1;\n\n      try {\n        callback.call(self);\n      } finally {\n        if (inProgress > 1) {\n          Promise.resolve().then(thenCallback);\n          pending = true;\n        }\n        inProgress = 0;\n      }\n    });\n  }\n\n  return wrap(coalescingWrapper, callback);\n};\n\nfunction wrap<\n  TWrapper extends AnyFunction,\n  TWrapped extends AnyFunction,\n>(wrapper: TWrapper, wrapped: TWrapped): TWrapper {\n  // Allow the wrapper to be used as a constructor function, just in case\n  // the wrapped function was meant to be used as a constructor.\n  wrapper.prototype = wrapped.prototype;\n\n  // https://medium.com/@cramforce/on-the-awesomeness-of-fn-displayname-9511933a714a\n  const name = wrapped.displayName || wrapped.name;\n  if (name) {\n    wrapper.displayName = name;\n  }\n\n  return wrapper;\n}\n"]}