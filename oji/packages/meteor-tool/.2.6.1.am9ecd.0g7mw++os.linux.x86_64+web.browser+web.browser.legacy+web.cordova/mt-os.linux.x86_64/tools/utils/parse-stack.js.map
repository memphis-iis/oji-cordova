{"version":3,"file":"tools/utils/parse-stack.js.map","mappings":"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","names":["module","parse","markBottom","markTop","err","stack","frames","split","slice","filter","f","match","indexOfFiberSplit","indexOf","outsideFiber","parseStackFrames","insideFiber","context","__bottom_mark__","apply","arguments","__top_mark__","stop","parsedFrames","some","frame","m","push","func","file","line","column","startsWith","length","Error"],"sourceRoot":"","sources":["tools/utils/parse-stack.ts"],"sourcesContent":["type ParsedStackFrame = {\n  /**\n   * filename as it appears in the stack\n   */\n  file: string;\n\n  /**\n   * 1-indexed line in the file\n   */\n  line: number | null;\n\n  /**\n   * 1-indexed column in the line\n   */\n  column: number | null;\n\n  /**\n   * name of the function in the frame\n   */\n  func: string | null;\n};\n\n/**\n * Returns the stack associated with an error as an array.\n * More recently called functions appear first.\n * \n * Accomplishes this by parsing the text representation of the stack\n * with regular expressions. Unlikey to work anywhere but v8.\n * \n * If a function on the stack has been marked with mark(), will not\n * return anything past that function. We call this the \"user portion\"\n * of the stack.\n */\nexport function parse(err: Error): {\n  insideFiber?: ParsedStackFrame[],\n  outsideFiber?: ParsedStackFrame[],\n} {\n  const stack = err.stack;\n  if (typeof stack !== \"string\") {\n    return {};\n  }\n\n  // at least the first line is the exception\n  const frames = stack.split(\"\\n\").slice(1)\n    // longjohn adds lines of the form '---' (45 times) to separate\n    // the trace across async boundaries. It's not clear if we need to\n    // separate the trace in the same way we do for future boundaries below\n    // (it's not clear that that code is still useful either)\n    // so for now, we'll just remove such lines\n    .filter(f => ! f.match(/^\\-{45}$/));\n  \n  // \"    - - - - -\"\n  // This is something added when you throw an Error through a Future. The\n  // stack above the dashes is the stack of the 'wait' call; the stack below\n  // is the stack inside the fiber where the Error is originally\n  // constructed.\n  // XXX This code assumes that the stack trace can only be split once. It's not\n  // clear whether this can happen multiple times.\n  const indexOfFiberSplit = frames.indexOf('    - - - - -');\n\n  if (indexOfFiberSplit === -1) {\n    // This is a normal stack trace, not a split fiber stack trace\n    return {\n      outsideFiber: parseStackFrames(frames)\n    }\n  }\n\n  // If this is a split stack trace from a future, parse the frames above and\n  // below the split separately.\n  const outsideFiber = parseStackFrames(frames);\n  const insideFiber = parseStackFrames(frames.slice(indexOfFiberSplit + 1));\n\n  return {\n    insideFiber,\n    outsideFiber\n  };\n}\n\n/**\n * Decorator. Mark the point at which a stack trace returned by\n * parse() should stop: no frames earlier than this point will be\n * included in the parsed stack. Confusingly, in the argot of the\n * times, you'd say that frames \"higher up\" than this or \"above\" this\n * will not be returned, but you'd also say that those frames are \"at\n * the bottom of the stack\". Frames below the bottom are the outer\n * context of the framework running the user's code.\n */\nexport function markBottom(f: Function, context: any) {\n  /* eslint-disable camelcase */\n  return function __bottom_mark__() {\n    // @ts-ignore: Implicit this\n    return f.apply(context || this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\n/**\n * Decorator. Mark the point at which a stack trace returned by\n * parse() should begin: no frames later than this point will be\n * included in the parsed stack. The opposite of markBottom().\n * Frames above the top are helper functions defined by the\n * framework and executed by user code whose internal behavior\n * should not be exposed.\n */\nexport function markTop(f: Function, context: any) {\n  /* eslint-disable camelcase */\n  return function __top_mark__() {\n    // @ts-ignore: Implicit this\n    return f.apply(context || this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\nfunction parseStackFrames(frames: string[]): ParsedStackFrame[] {\n  let stop = false;\n  let parsedFrames: ParsedStackFrame[] = [];\n\n  frames.some(frame => {\n    if (stop) {\n      return true;\n    }\n\n    let m;\n\n    /* eslint-disable max-len */\n    if (m = frame.match(/^\\s*at\\s*((new )?.+?)\\s*(\\[as\\s*([^\\]]*)\\]\\s*)?\\((.*?)(:(\\d+))?(:(\\d+))?\\)\\s*$/)) {\n      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n      // \"    at My.Function (/path/to/myfile.js:532:39)\"\n      // \"    at Array.forEach (native)\"\n      // \"    at new My.Class (file.js:1:2)\"\n      // \"    at [object Object].main.registerCommand.name [as func] (meteor/tools/commands.js:1225:19)\"\n      // \"    at __top_mark__ [as matchErr] (meteor/tools/parse-stack.js:82:14)\"\n      //\n      // In that last example, it is not at all clear to me what the\n      // 'as' stanza refers to, but it is in m[3] if you find a use for it.\n      if (m[1].match(/(?:^|\\.)__top_mark__$/)) {\n        // m[1] could be Object.__top_mark__ or something like that\n        // depending on where exactly you put the function returned by\n        // markTop\n        parsedFrames = [];\n        return;\n      }\n\n      if (m[1].match(/(?:^|\\.)__bottom_mark__$/)) {\n        return stop = true;\n      }\n\n      parsedFrames.push({\n        func: m[1],\n        file: m[5],\n        line: m[7] ? +m[7] : null,\n        column: m[9] ? +m[9] : null\n      });\n      return;\n    }\n    /* eslint-enable max-len */\n\n    if (m = frame.match(/^\\s*at\\s+(.+?)(:(\\d+))?(:(\\d+))?\\s*$/)) {\n      // \"    at /path/to/myfile.js:532:39\"\n      parsedFrames.push({\n        file: m[1],\n        line: m[3] ? +m[3] : null,\n        column: m[5] ? +m[5] : null,\n        func: null,\n      });\n      return;\n    }\n\n    if (m = frame.match(/^\\s*-\\s*-\\s*-\\s*-\\s*-\\s*$/)) {\n      // Stop parsing if we reach a stack split from a Future\n      return stop = true;\n    }\n\n    if (frame.startsWith(\" => awaited here:\")) {\n      // The meteor-promise library inserts \" => awaited here:\" lines to\n      // indicate async boundaries.\n      return stop = true;\n    }\n\n    if (parsedFrames.length === 0) {\n      // We haven't found any stack frames, so probably we have newlines in the\n      // error message. Just skip this line.\n      return;\n    }\n\n    throw new Error(`Couldn't parse stack frame: '${frame}'`);\n  });\n\n  return parsedFrames;\n}\n"]}