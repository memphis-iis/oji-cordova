{"version":3,"sources":["meteor://ðŸ’»app/packages/caching-compiler/caching-compiler.js","meteor://ðŸ’»app/packages/caching-compiler/multi-file-caching-compiler.js"],"names":[],"mappings":"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","file":"/packages/caching-compiler.js","sourcesContent":["const fs = Plugin.fs;\nconst path = Plugin.path;\nconst createHash = Npm.require('crypto').createHash;\nconst assert = Npm.require('assert');\nconst Future = Npm.require('fibers/future');\nconst LRU = Npm.require('lru-cache');\nconst async = Npm.require('async');\n\n// Base class for CachingCompiler and MultiFileCachingCompiler.\nCachingCompilerBase = class CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    this._compilerName = compilerName;\n    this._maxParallelism = maxParallelism;\n    const envVarPrefix = 'METEOR_' + compilerName.toUpperCase() + '_CACHE_';\n\n    const debugEnvVar = envVarPrefix + 'DEBUG';\n    this._cacheDebugEnabled = !! process.env[debugEnvVar];\n\n    const cacheSizeEnvVar = envVarPrefix + 'SIZE';\n    this._cacheSize = +process.env[cacheSizeEnvVar] || defaultCacheSize;\n\n    this._diskCache = null;\n\n    // For testing.\n    this._callCount = 0;\n  }\n\n  // Your subclass must override this method to define the key used to identify\n  // a particular version of an InputFile.\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), returns a cache key that represents\n  // it. This cache key can be any JSON value (it will be converted internally\n  // into a hash).  This should reflect any aspect of the InputFile that affects\n  // the output of `compileOneFile`. Typically you'll want to include\n  // `inputFile.getDeclaredExports()`, and perhaps\n  // `inputFile.getPathInPackage()` or `inputFile.getDeclaredExports` if\n  // `compileOneFile` pays attention to them.\n  //\n  // Note that for MultiFileCachingCompiler, your cache key doesn't need to\n  // include the file's path, because that is automatically taken into account\n  // by the implementation. CachingCompiler subclasses can choose whether or not\n  // to include the file's path in the cache key.\n  getCacheKey(inputFile) {\n    throw Error('CachingCompiler subclass should implement getCacheKey!');\n  }\n\n  // Your subclass must override this method to define how a CompileResult\n  // translates into adding assets to the bundle.\n  //\n  // This method is given an InputFile (the data type passed to\n  // processFilesForTarget as part of the Plugin.registerCompiler API) and a\n  // CompileResult (either returned directly from compileOneFile or read from\n  // the cache).  It should call methods like `inputFile.addJavaScript`\n  // and `inputFile.error`.\n  addCompileResult(inputFile, compileResult) {\n    throw Error('CachingCompiler subclass should implement addCompileResult!');\n  }\n\n  // Your subclass must override this method to define the size of a\n  // CompilerResult (used by the in-memory cache to limit the total amount of\n  // data cached).\n  compileResultSize(compileResult) {\n    throw Error('CachingCompiler subclass should implement compileResultSize!');\n  }\n\n  // Your subclass may override this method to define an alternate way of\n  // stringifying CompilerResults.  Takes a CompileResult and returns a string.\n  stringifyCompileResult(compileResult) {\n    return JSON.stringify(compileResult);\n  }\n  // Your subclass may override this method to define an alternate way of\n  // parsing CompilerResults from string.  Takes a string and returns a\n  // CompileResult.  If the string doesn't represent a valid CompileResult, you\n  // may want to return null instead of throwing, which will make\n  // CachingCompiler ignore the cache.\n  parseCompileResult(stringifiedCompileResult) {\n    return this._parseJSONOrNull(stringifiedCompileResult);\n  }\n  _parseJSONOrNull(json) {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      if (e instanceof SyntaxError)\n        return null;\n      throw e;\n    }\n  }\n\n  _cacheDebug(message) {\n    if (!this._cacheDebugEnabled)\n      return;\n    console.log(`CACHE(${ this._compilerName }): ${ message }`);\n  }\n\n  setDiskCacheDirectory(diskCache) {\n    if (this._diskCache)\n      throw Error('setDiskCacheDirectory called twice?');\n    this._diskCache = diskCache;\n  }\n\n  // Since so many compilers will need to calculate the size of a SourceMap in\n  // their compileResultSize, this method is provided.\n  sourceMapSize(sm) {\n    if (! sm) return 0;\n    // sum the length of sources and the mappings, the size of\n    // metadata is ignored, but it is not a big deal\n    return sm.mappings.length\n      + (sm.sourcesContent || []).reduce(function (soFar, current) {\n        return soFar + (current ? current.length : 0);\n      }, 0);\n  }\n\n  // Borrowed from another MIT-licensed project that benjamn wrote:\n  // https://github.com/reactjs/commoner/blob/235d54a12c/lib/util.js#L136-L168\n  _deepHash(val) {\n    const hash = createHash('sha1');\n    let type = typeof val;\n\n    if (val === null) {\n      type = 'null';\n    }\n    hash.update(type + '\\0');\n\n    switch (type) {\n    case 'object':\n      const keys = Object.keys(val);\n\n      // Array keys will already be sorted.\n      if (! Array.isArray(val)) {\n        keys.sort();\n      }\n\n      keys.forEach((key) => {\n        if (typeof val[key] === 'function') {\n          // Silently ignore nested methods, but nevertheless complain below\n          // if the root value is a function.\n          return;\n        }\n\n        hash.update(key + '\\0').update(this._deepHash(val[key]));\n      });\n\n      break;\n\n    case 'function':\n      assert.ok(false, 'cannot hash function objects');\n      break;\n\n    default:\n      hash.update('' + val);\n      break;\n    }\n\n    return hash.digest('hex');\n  }\n\n  // We want to write the file atomically. But we also don't want to block\n  // processing on the file write.\n  _writeFileAsync(filename, contents) {\n    const tempFilename = filename + '.tmp.' + Random.id();\n    fs.writeFile(tempFilename, contents, (err) => {\n      // ignore errors, it's just a cache\n      if (err) {\n        return;\n      }\n      fs.rename(tempFilename, filename, (err) => {\n        // ignore this error too.\n      });\n    });\n  }\n\n  // Helper function. Returns the body of the file as a string, or null if it\n  // doesn't exist.\n  _readFileOrNull(filename) {\n    try {\n      return fs.readFileSync(filename, 'utf8');\n    } catch (e) {\n      if (e && e.code === 'ENOENT')\n        return null;\n      throw e;\n    }\n  }\n}\n\n// CachingCompiler is a class designed to be used with Plugin.registerCompiler\n// which implements in-memory and on-disk caches for the files that it\n// processes.  You should subclass CachingCompiler and define the following\n// methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.\n//\n// CachingCompiler assumes that files are processed independently of each other;\n// there is no 'import' directive allowing one file to reference another.  That\n// is, editing one file should only require that file to be rebuilt, not other\n// files.\n//\n// The data that is cached for each file is of a type that is (implicitly)\n// defined by your subclass. CachingCompiler refers to this type as\n// `CompileResult`, but this isn't a single type: it's up to your subclass to\n// decide what type of data this is.  You should document what your subclass's\n// CompileResult type is.\n//\n// Your subclass's compiler should call the superclass compiler specifying the\n// compiler name (used to generate environment variables for debugging and\n// tweaking in-memory cache size) and the default cache size.\n//\n// By default, CachingCompiler processes each file in \"parallel\". That is, if it\n// needs to yield to read from the disk cache, or if getCacheKey,\n// compileOneFile, or addCompileResult yields, it will start processing the next\n// few files. To set how many files can be processed in parallel (including\n// setting it to 1 if your subclass doesn't support any parallelism), pass the\n// maxParallelism option to the superclass constructor.\n//\n// For example (using ES2015 via the ecmascript package):\n//\n//   class AwesomeCompiler extends CachingCompiler {\n//     constructor() {\n//       super({\n//         compilerName: 'awesome',\n//         defaultCacheSize: 1024*1024*10,\n//       });\n//     }\n//     // ... define the other methods\n//   }\n//   Plugin.registerCompile({\n//     extensions: ['awesome'],\n//   }, () => new AwesomeCompiler());\n//\n// XXX maybe compileResultSize and stringifyCompileResult should just be methods\n// on CompileResult? Sort of hard to do that with parseCompileResult.\nCachingCompiler = class CachingCompiler extends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism = 20,\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from a hashed cache key to a compileResult.\n    this._cache = new LRU({\n      max: this._cacheSize,\n      length: (value) => this.compileResultSize(value),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Given an InputFile (the data type passed to processFilesForTarget as part\n  // of the Plugin.registerCompiler API), compiles the file and returns a\n  // CompileResult (the cacheable data type specific to your subclass).\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile) {\n    throw Error('CachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API. If\n  // you have processing you want to perform at the beginning or end of a\n  // processing phase, you may want to override this method and call the\n  // superclass implementation from within your method.\n  processFilesForTarget(inputFiles) {\n    const cacheMisses = [];\n\n    const future = new Future;\n    async.eachLimit(inputFiles, this._maxParallelism, (inputFile, cb) => {\n      let error = null;\n      try {\n        const cacheKey = this._deepHash(this.getCacheKey(inputFile));\n        let compileResult = this._cache.get(cacheKey);\n\n        if (! compileResult) {\n          compileResult = this._readCache(cacheKey);\n          if (compileResult) {\n            this._cacheDebug(`Loaded ${ inputFile.getDisplayPath() }`);\n          }\n        }\n\n        if (! compileResult) {\n          cacheMisses.push(inputFile.getDisplayPath());\n          compileResult = this.compileOneFile(inputFile);\n\n          if (! compileResult) {\n            // compileOneFile should have called inputFile.error.\n            //  We don't cache failures for now.\n            return;\n          }\n\n          // Save what we've compiled.\n          this._cache.set(cacheKey, compileResult);\n          this._writeCacheAsync(cacheKey, compileResult);\n        }\n\n        this.addCompileResult(inputFile, compileResult);\n      } catch (e) {\n        error = e;\n      } finally {\n        cb(error);\n      }\n    }, future.resolver());\n    future.wait();\n\n    if (this._cacheDebugEnabled) {\n      cacheMisses.sort();\n      this._cacheDebug(\n        `Ran (#${ ++this._callCount }) on: ${ JSON.stringify(cacheMisses) }`);\n    }\n  }\n\n  _cacheFilename(cacheKey) {\n    // We want cacheKeys to be hex so that they work on any FS and never end in\n    // .cache.\n    if (!/^[a-f0-9]+$/.test(cacheKey)) {\n      throw Error('bad cacheKey: ' + cacheKey);\n    }\n    return path.join(this._diskCache, cacheKey + '.cache');\n  }\n  // Load a cache entry from disk. Returns the compileResult object\n  // and loads it into the in-memory cache too.\n  _readCache(cacheKey) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const compileResult = this._readAndParseCompileResultOrNull(cacheFilename);\n    if (! compileResult) {\n      return null;\n    }\n    this._cache.set(cacheKey, compileResult);\n    return compileResult;\n  }\n  _writeCacheAsync(cacheKey, compileResult) {\n    if (! this._diskCache)\n      return;\n    const cacheFilename = this._cacheFilename(cacheKey);\n    const cacheContents = this.stringifyCompileResult(compileResult);\n    this._writeFileAsync(cacheFilename, cacheContents);\n  }\n\n  // Returns null if the file does not exist or can't be parsed; otherwise\n  // returns the parsed compileResult in the file.\n  _readAndParseCompileResultOrNull(filename) {\n    const raw = this._readFileOrNull(filename);\n    return this.parseCompileResult(raw);\n  }\n}\n","const path = Plugin.path;\nconst Future = Npm.require('fibers/future');\nconst LRU = Npm.require('lru-cache');\nconst async = Npm.require('async');\n\n// MultiFileCachingCompiler is like CachingCompiler, but for implementing\n// languages which allow files to reference each other, such as CSS\n// preprocessors with `@import` directives.\n//\n// Like CachingCompiler, you should subclass MultiFileCachingCompiler and define\n// the following methods: getCacheKey, compileOneFile, addCompileResult, and\n// compileResultSize.  compileOneFile gets an additional allFiles argument and\n// returns an array of referenced import paths in addition to the CompileResult.\n// You may also override isRoot and getAbsoluteImportPath to customize\n// MultiFileCachingCompiler further.\nMultiFileCachingCompiler = class MultiFileCachingCompiler\nextends CachingCompilerBase {\n  constructor({\n    compilerName,\n    defaultCacheSize,\n    maxParallelism\n  }) {\n    super({compilerName, defaultCacheSize, maxParallelism});\n\n    // Maps from absolute import path to { compileResult, cacheKeys }, where\n    // cacheKeys is an object mapping from absolute import path to hashed\n    // cacheKey for each file referenced by this file (including itself).\n    this._cache = new LRU({\n      max: this._cacheSize,\n      // We ignore the size of cacheKeys here.\n      length: (value) => this.compileResultSize(value.compileResult),\n    });\n  }\n\n  // Your subclass must override this method to define the transformation from\n  // InputFile to its cacheable CompileResult).\n  //\n  // Arguments:\n  //   - inputFile is the InputFile to process\n  //   - allFiles is a a Map mapping from absolute import path to InputFile of\n  //     all files being processed in the target\n  // Returns an object with keys:\n  //   - compileResult: the CompileResult (the cacheable data type specific to\n  //     your subclass).\n  //   - referencedImportPaths: an array of absolute import paths of files\n  //     which were refererenced by the current file.  The current file\n  //     is included implicitly.\n  //\n  // This method is not called on files when a valid cache entry exists in\n  // memory or on disk.\n  //\n  // On a compile error, you should call `inputFile.error` appropriately and\n  // return null; this will not be cached.\n  //\n  // This method should not call `inputFile.addJavaScript` and similar files!\n  // That's what addCompileResult is for.\n  compileOneFile(inputFile, allFiles) {\n    throw Error(\n      'MultiFileCachingCompiler subclass should implement compileOneFile!');\n  }\n\n  // Your subclass may override this to declare that a file is not a \"root\" ---\n  // ie, it can be included from other files but is not processed on its own. In\n  // this case, MultiFileCachingCompiler won't waste time trying to look for a\n  // cache for its compilation on disk.\n  isRoot(inputFile) {\n    return true;\n  }\n\n  // Returns the absolute import path for an InputFile. By default, this is a\n  // path is a path of the form \"{package}/path/to/file\" for files in packages\n  // and \"{}/path/to/file\" for files in apps. Your subclass may override and/or\n  // call this method.\n  getAbsoluteImportPath(inputFile) {\n    if (inputFile.getPackageName() === null) {\n      return '{}/' + inputFile.getPathInPackage();\n    }\n    return '{' + inputFile.getPackageName() + '}/'\n      + inputFile.getPathInPackage();\n  }\n\n  // The processFilesForTarget method from the Plugin.registerCompiler API.\n  processFilesForTarget(inputFiles) {\n    const allFiles = new Map;\n    const cacheKeyMap = new Map;\n    const cacheMisses = [];\n\n    inputFiles.forEach((inputFile) => {\n      const importPath = this.getAbsoluteImportPath(inputFile);\n      allFiles.set(importPath, inputFile);\n      cacheKeyMap.set(importPath, this._deepHash(this.getCacheKey(inputFile)));\n    });\n\n    const allProcessedFuture = new Future;\n    async.eachLimit(inputFiles, this._maxParallelism, (inputFile, cb) => {\n      let error = null;\n      try {\n        // If this isn't a root, skip it (and definitely don't waste time\n        // looking for a cache file that won't be there).\n        if (!this.isRoot(inputFile)) {\n          return;\n        }\n\n        const absoluteImportPath = this.getAbsoluteImportPath(inputFile);\n        let cacheEntry = this._cache.get(absoluteImportPath);\n        if (! cacheEntry) {\n          cacheEntry = this._readCache(absoluteImportPath);\n          if (cacheEntry) {\n            this._cacheDebug(`Loaded ${ absoluteImportPath }`);\n          }\n        }\n        if (! (cacheEntry && this._cacheEntryValid(cacheEntry, cacheKeyMap))) {\n          cacheMisses.push(inputFile.getDisplayPath());\n\n          const compileOneFileReturn = this.compileOneFile(inputFile, allFiles);\n          if (! compileOneFileReturn) {\n            // compileOneFile should have called inputFile.error.\n            //  We don't cache failures for now.\n            return;\n          }\n          const {compileResult, referencedImportPaths} = compileOneFileReturn;\n\n          cacheEntry = {\n            compileResult,\n            cacheKeys: {\n              // Include the hashed cache key of the file itself...\n              [absoluteImportPath]: cacheKeyMap.get(absoluteImportPath)\n            }\n          };\n\n          // ... and of the other referenced files.\n          referencedImportPaths.forEach((path) => {\n            if (!cacheKeyMap.has(path)) {\n              throw Error(`Unknown absolute import path ${ path }`);\n            }\n            cacheEntry.cacheKeys[path] = cacheKeyMap.get(path);\n          });\n\n          // Save the cache entry.\n          this._cache.set(absoluteImportPath, cacheEntry);\n          this._writeCacheAsync(absoluteImportPath, cacheEntry);\n        }\n\n        this.addCompileResult(inputFile, cacheEntry.compileResult);\n      } catch (e) {\n        error = e;\n      } finally {\n        cb(error);\n      }\n    }, allProcessedFuture.resolver());\n    allProcessedFuture.wait();\n\n    if (this._cacheDebugEnabled) {\n      cacheMisses.sort();\n      this._cacheDebug(\n        `Ran (#${ ++this._callCount }) on: ${ JSON.stringify(cacheMisses) }`);\n    }\n  }\n\n  _cacheEntryValid(cacheEntry, cacheKeyMap) {\n    return Object.keys(cacheEntry.cacheKeys).every(\n      (path) => cacheEntry.cacheKeys[path] === cacheKeyMap.get(path)\n    );\n  }\n\n  // The format of a cache file on disk is the JSON-stringified cacheKeys\n  // object, a newline, followed by the CompileResult as returned from\n  // this.stringifyCompileResult.\n  _cacheFilename(absoluteImportPath) {\n    return path.join(this._diskCache,\n                     this._deepHash(absoluteImportPath) + '.cache');\n  }\n  // Loads a {compileResult, cacheKeys} cache entry from disk. Returns the whole\n  // cache entry and loads it into the in-memory cache too.\n  _readCache(absoluteImportPath) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(absoluteImportPath);\n    const raw = this._readFileOrNull(cacheFilename);\n    if (!raw) {\n      return null;\n    }\n\n    // Split on newline.\n    const newlineIndex = raw.indexOf('\\n');\n    if (newlineIndex === -1) {\n      return null;\n    }\n    const cacheKeysString = raw.substring(0, newlineIndex);\n    const compileResultString = raw.substring(newlineIndex + 1);\n\n    const cacheKeys = this._parseJSONOrNull(cacheKeysString);\n    if (!cacheKeys) {\n      return null;\n    }\n    const compileResult = this.parseCompileResult(compileResultString);\n    if (! compileResult) {\n      return null;\n    }\n\n    const cacheEntry = {compileResult, cacheKeys};\n    this._cache.set(absoluteImportPath, cacheEntry);\n    return cacheEntry;\n  }\n  _writeCacheAsync(absoluteImportPath, cacheEntry) {\n    if (! this._diskCache) {\n      return null;\n    }\n    const cacheFilename = this._cacheFilename(absoluteImportPath);\n    const cacheContents =\n            JSON.stringify(cacheEntry.cacheKeys) + '\\n'\n            + this.stringifyCompileResult(cacheEntry.compileResult);\n    this._writeFileAsync(cacheFilename, cacheContents);\n  }\n}\n"]}